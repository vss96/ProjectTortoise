{"distinguished":null,"retrieved_on":1473808074,"gilded":0,"parent_id":"t1_cu3k6","id":"cu3sm","edited":false,"author_flair_text":null,"author":"notfancy","score":2,"ups":2,"created_utc":1165582654,"author_flair_css_class":null,"subreddit":"programming","subreddit_id":"t5_2fwo","stickied":false,"link_id":"t3_u1h2","controversiality":0,"body":"OCaml's standard library fails with exceptions, as a matter of style. This is because exception handling is extremely cheap in OCaml, and you can pattern-match on the exception much as you would with an algebraic datatype. However, this means that concerns are confounded: you cannot distinguish between a fatal error condition and a normal but exceptional value.\r\n\r\nCase in point is the reading of input channels: end of file is signalled by the `End_of_file` exception, while it would be more natural to return an `'a option`, and restrict exceptions to genuine I/O errors. Code for doing file input in OCaml then comes in two flavors. The imperative:\r\n\r\n    let fold_input f e inch =\r\n       let x = ref e in\r\n       try while true do\r\n          let c = input_char inch in x := f !x c\r\n       done with End_of_file -&gt; !x\r\n\r\nThe functional:\r\n\r\n    let rec fold_input f e inch =\r\n       let try_input inch = try Some (input_char inch) with End_of_file -&gt; None\r\n       in match try_input inch with\r\n       | Some c -&gt; fold_input f (f e c) inch\r\n       | None -&gt; e\r\n\r\nThis is borne out of the fact that a recursive call inside a try handler is *not* in tail position, so every recursion (obviously) pushes a new stack handler.\r\n\r\n*Edit:* grammar.","timestamp_epoch":1566236763,"message_id":"15830-d0f4751b-ff49-4ba4-b606-fb37c0aef1cf-1566236763"}
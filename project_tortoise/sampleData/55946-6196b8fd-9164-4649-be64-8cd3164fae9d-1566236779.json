{"subreddit":"programming","score":2,"ups":2,"created_utc":1167353544,"author_flair_css_class":null,"body":"I know about all this. But this don't changes the fact, that the state (call it like you want) has to get to the point of the program where you want to access or modify it - and this can get very ugly and also breaks existing contracts because it changes the type of a function.\r\n\r\nProgramming is about code reuse, you can't always write everything from scratch. But if we make state explicit we can't reuse code anymore which requires another kind of state. With generic data types this can be solved a bit, but nonetheless the conciseness and clarity of the code suffers if I have lots of functions which only take and return data to chain it thru.\r\n\r\nNow it's an interesting question if it's possible to make all state explicit and still maintain code reuseability. Monads tackle this problem and solve it to a certain degree, but I think they are not there yet. \r\n\r\nI think it all boils down to better compiler support to hide these kind of things - like Haskell hides the bind operator with the special do-syntax. Just one step further. But I also know that many programmers are a bit conservative with those things and want those 'as pure as possible' languages.  But since Haskell is a rather rich functional language I think such an extension could really fit.\r\n\r\nAnd yes, there is a filterM - but only for lists, there is none for sets for example.\r\n\r\nOCaml's mutation would work in all those examples, but because it violates referential integrity it has the mentioned disadvantages. \r\n\r\nI will take a look at Clean sometimes to see how well their uniqueness typing works. Problem with Clean is that the community seems to be smaller. Also I'm a bit concerned about the completeness of their implementation.\r\n","controversiality":0,"subreddit_id":"t5_2fwo","stickied":false,"link_id":"t3_w79v","gilded":0,"distinguished":null,"retrieved_on":1473809579,"author":"kawa","author_flair_text":null,"edited":false,"parent_id":"t1_cwb0z","id":"cwb5r","timestamp_epoch":1566236779,"message_id":"55946-6196b8fd-9164-4649-be64-8cd3164fae9d-1566236779"}
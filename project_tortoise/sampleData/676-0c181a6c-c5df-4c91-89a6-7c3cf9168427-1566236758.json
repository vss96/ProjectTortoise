{"body":"Haskell's precedence rules are throwing you.\r\n\r\n    f x (ys, xs) = (if p x then ys else x : xs, x : xs)\r\n\r\nparses as\r\n\r\n    f x (ys, xs) = ((if p x then ys else x : xs), (x : xs))\r\n\r\nTo answer the second part of your question: I find it easiest to think about fold in terms of replacing (:) with an arbitrary binop and [] with an arbitrary constant.  Thus, foldl becomes:\r\n\r\n    ((((elem1 `op` elem2) `op` elem3) `op` ...) `op` c)\r\n\r\nAnd foldr becomes:\r\n\r\n    (elem1 `op` (elem2 `op` (elem3 `op` (... `op` c))))\r\n\r\nNow, anytime your op (`f` in the example) includes a cons, you *have to* use foldr.  Cons is always right-associative, so if you replace cons by cons but change the expression from right-associative to left-associative, you've changed the meaning.\r\n\r\nSince dropWhile uses cons (or a function thereof), we must use foldr.  However, foldr works from right-to-left.  And dropWhile's effect is to throw away the leftmost part of the list.   Fold has only the information in its return value available; if you need more information in the computation, you need to explicitly put it into a tuple and pass that down the computation.\r\n\r\nSee why we need to save the original list now?  If we didn't, dropWhile would've already thrown it away by the time it determines whether or not to keep it.\r\n\r\nThe rest of the function's pretty simple, once you get the precedence right.  With each step of the fold function, we add the left element onto the front of our total list.  We also check to see if it fits our predicate.  If so, we drop it (i.e., return ys, the previous return value).  If not, we cons it on to the head of the result list.  The second element of the pair is effectively an accumulator that stores the reconstructed list; the first element of the pair is a pointer into that list that stores where the new list should start.\r\n\r\n\r\nStrict vs. lazy doesn't matter with fold, except for efficiency &amp; nontermination.  You do have to watch out for one thing: foldl is tail-recursive in a strict language, but builds up an O(N) chain of unevaluated thunks in a lazy language.  As a result, most Haskell programmers either use foldr or foldl', the strict version of foldl.","controversiality":0,"subreddit_id":"t5_2fwo","stickied":false,"link_id":"t3_t5vi","subreddit":"programming","ups":11,"score":11,"created_utc":1164952683,"author_flair_css_class":null,"author":"nostrademons","author_flair_text":null,"edited":false,"id":"ct727","parent_id":"t1_ct71d","gilded":0,"distinguished":null,"retrieved_on":1473807462,"timestamp_epoch":1566236758,"message_id":"676-0c181a6c-c5df-4c91-89a6-7c3cf9168427-1566236758"}
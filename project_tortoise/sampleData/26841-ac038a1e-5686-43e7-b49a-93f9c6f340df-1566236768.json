{"distinguished":null,"retrieved_on":1473808474,"gilded":0,"id":"cuozm","edited":false,"parent_id":"t1_cuotj","author_flair_text":null,"author":"wesdyer","score":7,"ups":7,"created_utc":1166042990,"author_flair_css_class":null,"subreddit":"programming","subreddit_id":"t5_2fwo","stickied":false,"link_id":"t3_uocv","controversiality":0,"body":"It seems that there is a slight misunderstanding concerning Anders's comments.  He is not only talking about what Microsoft is doing in C# 3.0 but also what they are thinking about doing beyond that point.  Furthermore, he did not say that he wants C# 3.0 to be dynamic but rather he wanted to find what salient points about dynamic languages can be incorporated into C# that would help programmers.  Furthermore, as Microsoft adds dynamic languages like IronPython to the .NET platform it is important that languages like C# can interact with it in a first class way so there is some work to be done there.\r\n\r\nI also want to address some of your specific comments about C# 3.0.\r\n\r\n\"So they add a \"var\" type, start embedded SQL in the code (icky), and now they claim C# is dynamic?\"\r\n\r\nMicrosoft has made no such claim, in fact the claim is exactly the contrary.  Microsoft claims that with the C# 3.0 features, the language is still statically typed.  Second, the type inference in C# 3.0 extends beyond the var keyword (var is *not* a type).  var is a keyword that instructs the compiler to infer the type of a local variable based on the expression that is used to initialize the variable.  Type inference is also used to infer the type parameters for a generic method when no type parameters are given.  This is especially important for two reasons:  the new query syntax is translated down to a series of method calls to possibly generic methods with no given type parameters and C# 3.0 also introduces anonymous types which would preclude naming them.  Type inference is also used a few other places but the most notable places I have already mentioned.\r\n\r\nC# 3.0 does not include embedded SQL.  It does include query comprehensions which are more accurately related to list comprehensions (especially Haskell's list comprehensions) than to SQL.  The syntax provides a way to specify in a declarative manner a set of sources, filters, projections, and a few other niceties but it does *not* necessarily translate them into SQL (although that is possible).  In fact, the C# spec only states that queries we be translated into a sequence of method calls that are then bound using normal overload resolution rules.\r\n\r\nBut even the feature set that you mention is not the whole story.  C# 3.0 also adds lambdas, expression trees (the ability to quote lambdas), anonymous types, extension methods, implicitly typed arrays, object and collection initializers, default properties, and partial methods.  These features do not make C# dynamic at all; they do bring many features from functional languages into C# and make C# a more expression oriented language, but it should also be noted that they do not make C# a functional language like ML, Haskell, or others.  C# is as Anders stated a melding of great ideas from many sources and it appears that the melding is ongoing.","timestamp_epoch":1566236768,"message_id":"26841-ac038a1e-5686-43e7-b49a-93f9c6f340df-1566236768"}
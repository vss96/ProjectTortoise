{"gilded":0,"retrieved_on":1473807490,"distinguished":null,"author":"mjd","author_flair_text":null,"parent_id":"t1_ct88s","edited":false,"id":"ct8ju","subreddit":"programming","author_flair_css_class":null,"created_utc":1164988318,"score":6,"ups":6,"controversiality":0,"body":"Another interesting matter that just came to my attention last week (while reading Abadi and Cardelli's book *A Theory of Objects*) is that people always call Java and C++ \"statically typed\", but they are not, at least not in the sense that type information is completely determined at compile time.  Consider for example some class *C* which has a  method *M*, and a derived class *D* which overrides *M*.    *C* also has the following \"foo\" method:\r\n\r\n   void foo (C c) {\r\n      return c.M();\r\n   }\r\n\r\nWhich *M* method is called here?  It depends---at run time---on whether the argument to \"foo\" is an instance of class *C* or of class *D*.  If the language were truly statically typed, \"c.M()\" would always call \"C::M\", never \r\n\"D::M\".  But no object-oriented language actually works that way.  They are all dynamically typed.  \r\n\r\nThat doesn't stop people from calling them statically typed.\r\n\r\n\r\n","link_id":"t3_t7v9","stickied":false,"subreddit_id":"t5_2fwo","timestamp_epoch":1566236758,"message_id":"1319-18db1266-251c-4604-b03a-eb3511b2a02b-1566236758"}
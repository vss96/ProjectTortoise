{"author_flair_text":null,"author":"kawa","parent_id":"t1_cwal4","edited":false,"id":"cwaud","gilded":0,"retrieved_on":1473809574,"distinguished":null,"controversiality":0,"body":"I think I wasn't able to express my point clearly: I don't say that 'real' mutation is necessary. I only say that you need some kind of state to do certain kinds of algorithms. \r\n\r\nThis state has to be maintained somehow. You said practically the same with your \"transition function f of a -&gt; s -&gt; s\" while I used the words \"chain some kind of state thru your interpreter\" above.\r\n\r\nThis is quite simple in theory but it can get ugly in practice. Many examples about monads even use an example of state-chaining to show how ugly it is and how you can make it pretty again if you use a state monad instead.\r\n\r\nAnd to really use it, you need lots of custom functions. Consider \"map f list\"  for example. Without state easy to use, but later you discover that your f has to modify something of your chained state while mapping. Simply using \"map (\\v -&gt; f v st) list\" won't work because each computation gets a 'fresh' state instead of the state of the previous calculation now. \r\n\r\nSo you have to write a new map function. But that not easy because map functions are one of the primary means of iteration in functional programming. Thus every non-trivial data-type has a map function which you can't simply modify. Now monads come in handy because they only require to be part of the result instead of part of argument *and* result. \r\n\r\nSo it much more simple to use - but it still requires changing functions. Luckily a function like map can be lifted to monad form without touching the code. But this don't work with all types of functions. Look at 'filter :: (a -&gt; Bool) -&gt; b a -&gt; b a' function and tell me how to simply lift it to a monadic form. Maybe I'm blind and missed to obvious, but until now I haven't found a way.\r\n\r\nSo while I totally agree with you that functional programming has it's advantages, its also hard to overcome the problems mentioned here. They are solvable but it blurs the code. And because of this I prefer to not chain some dummy-state thru my code just to be sure to have it later. Same for executing everything into a dummy monad just to make it more easy to put it in a real monad if I need it later.\r\n\r\nMaybe there are ways out: Allow mutation like in Ocaml. Or let the compiler do the state-chaining (kind of) transparently like in Mercury. Or use uniqueness typing which allows mutation but is still referential transparent because it uses types to assure that mutations and accesses won't conflict in a non-referential transparent way (implemented in Clean, a language very similar to Haskell). But I haven't used the last two methods practically so I can't say anything about the disadvantages.\r\n\r\nOf course it's also possible to create new algorithms which work totally different and don't even require mutation. But I suspect that this won't work too, because otherwise there wouldn't even be the need for monads.\r\n","stickied":false,"link_id":"t3_w79v","subreddit_id":"t5_2fwo","subreddit":"programming","created_utc":1167346863,"author_flair_css_class":null,"score":3,"ups":3,"timestamp_epoch":1566236779,"message_id":"55759-62019cee-81ee-44db-a081-4c6504e4937c-1566236779"}
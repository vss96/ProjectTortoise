{"author_flair_text":null,"author":"feijai","id":"ctp28","parent_id":"t3_to4l","edited":false,"gilded":0,"retrieved_on":1473807801,"distinguished":null,"body":"Full closures are already implementable in Java.  It's just a matter of syntax.\r\n\r\nA closure is a function, or a collection of functions, with references to outer nested scope.  Java does this with an anonymous class of methods with references to outer nested scope.  The Graham accumulator generator:\r\n\r\n    (defun acc (x) (lambda (y) (incf x y)))\r\n\r\nCan be done in Java this way:\r\n\r\n    pubic interface Acc { public double do(double y); }\r\n    \r\n    ....\r\n\r\n    public Acc acc(double x)\r\n    {\r\n        final double[] xx = new double[] { x };\r\n        return new Acc() { public double do(double y) { return xx[0] += y; } };\r\n    }\r\n\r\nWe then get the Accumulator with:\r\n\r\n    Acc a = myObj.acc(4);\r\n    a.do(5);  // returns 9\r\n    a.do(7);  // returns 16\r\n\r\nSome notes.  First, all local variables in outer nested scope entering a Java closure must be declared *final*.  This is a profoundly stupid rule with no good justification.  To be able to modify such variables (as in the case of the accumulator generator), we have to create a non-final inner mechanism, which we do, here, with an array.  If a decent Java compiler were to check when our variables musn't be final, it could do this for us.  Thus we could change the language to look like this:\r\n\r\n    pubic interface Acc { public double do(double y); }\r\n    \r\n    ....\r\n\r\n    public Acc acc(double x)\r\n    {\r\n        return new Acc() { public double do(double y) { return x += y; } };\r\n    }\r\n\r\nNow we're getting somewhere.  That's not only functionally a closure, it actually *looks* like a closure.  To get further, we'd need to modify Java so that it has functions instead of methods.  This is really what the cited guy is trying to do -- but I don't think it's all that useful without seriously breaking Java's syntax.  Although if interfaces or abstract classes have a single abstract method in them, we might clean up our syntax by making clear that the closure contains a single method in it.  We could do this by declaring the LAMBDA keyword to mean INTERFACE WITH THE SOLE METHOD IMPLEMENTED.  This might lead to:\r\n\r\n    pubic interface Acc { public double do(double y); }\r\n    \r\n    ....\r\n\r\n    public Acc acc(double x)\r\n    {\r\n        return lambda Acc(double y) { return x += y; };\r\n    }\r\n\r\nI don't know.  This might be useful in many contexts; but closures are more than single functions (though the ruby and python folks don't know that).  They can be GROUPS of functions which SHARE a common lexical variable, like this:\r\n\r\n    (let ((x 4))\r\n        (defun inc (a) (incf x a))\r\n        (defun dec (a) (decf x a)))\r\n\r\nNon-Lispers never see these closures because they're poorly-constructed lambda syntaxes don't support them.  But there's no reason why Anonymous classes can't do that of course.  It's trivial.","controversiality":0,"stickied":false,"link_id":"t3_to4l","subreddit_id":"t5_2fwo","subreddit":"programming","created_utc":1165329246,"author_flair_css_class":null,"score":-1,"ups":-1,"timestamp_epoch":1566236760,"message_id":"8930-a00bc8d9-0345-4d45-a15c-2c1070835a4a-1566236760"}
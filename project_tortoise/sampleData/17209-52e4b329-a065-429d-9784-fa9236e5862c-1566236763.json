{"author_flair_text":null,"author":"doubtingthomas","edited":false,"parent_id":"t1_cu5k2","id":"cu6dz","gilded":0,"distinguished":null,"retrieved_on":1473808124,"body":"Imagined or real lack of: tool support, libraries (and links to the standard native ones), developer base.\r\nAlso, the perception of unfamiliar features being impractical,  confusing, useless, or non-performant.  \r\n\r\nAlso, ignorance. That really is a big one. There are a number of languages that aren't commonly accepted as 'realistic' that have all the parts to be an excellent choice for a great many projects, but people tend to stick with what they know. I know X, X works, language Y isn't like X, therefore language Y isn't practical.\r\n\r\n\r\nEdit:\r\nAlso, it seems to me that most of the major libraries that programmers use from day-to-day make assumptions based on the currently popular languages and the further off an \"unrealistic\" language is, the harder it is to make a wrapper for that library that fits the language. Without solid corporate support or a really great community, the chances of getting a comprehensive, stable, and well-documented haskellish/pythonic/rubyish/whateverish binding to a boring-but-professionally-useful C/C++ library aren't great.","controversiality":0,"subreddit_id":"t5_2fwo","link_id":"t3_u5jo","stickied":false,"subreddit":"programming","score":4,"ups":4,"author_flair_css_class":null,"created_utc":1165617736,"timestamp_epoch":1566236763,"message_id":"17209-52e4b329-a065-429d-9784-fa9236e5862c-1566236763"}
{"subreddit":"programming","score":3,"ups":3,"created_utc":1166127714,"author_flair_css_class":null,"controversiality":0,"body":"If you _must_ use the recursive algorithm, memoization is fairly easy; I don't know of a generic builtin for memoizing things automatically, but my preferred approach would look like this:\r\n\r\n    def fib(n):\r\n        if n &lt; 2:\r\n            return n\r\n        return fib(n-1) + fib(n-2)\r\n    \r\n    class Memoize(object):\r\n        def __init__(self, func):\r\n             self.func = func\r\n             self._cache = {}\r\n        \r\n        def __call__(self, *args):\r\n            if not self._cache.has_key(args):\r\n                self._cache[args] = self.func(*args)\r\n            return self._cache[args]\r\n    \r\n    fib = Memoize(fib)\r\n\r\nIt also wouldn't be hard to re-create this as a decorator, so you could just put `@memoize` above the declaration of `fib` and have it happen automatically.\r\n\r\nBut generally I'd start with a faster algorithm; it's not terribly hard to get a roughly linear Fibonacci function (and, in fact, the algorithm for that is a key part to implementing Fibonacci as a Python generator).","subreddit_id":"t5_2fwo","stickied":false,"link_id":"t3_uqo3","gilded":0,"distinguished":null,"retrieved_on":1473808549,"author":"ubernostrum","author_flair_text":null,"id":"cut4g","edited":false,"parent_id":"t1_curuw","timestamp_epoch":1566236768,"message_id":"28765-69f5e842-aaec-4eb0-b685-1383d27ea42a-1566236768"}
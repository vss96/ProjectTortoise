{"retrieved_on":1473807547,"distinguished":null,"gilded":0,"edited":false,"id":"ctbmw","parent_id":"t1_ctbfh","author":"dons","author_flair_text":null,"author_flair_css_class":null,"created_utc":1165045895,"score":1,"ups":1,"subreddit":"programming","link_id":"t3_t7dz","stickied":false,"subreddit_id":"t5_2fwo","body":"Here's a 12 line/607 byte solution, for fun ;)\r\n\r\n    import List\r\n\r\n    main = putStr . unlines . map disp . solve . return . input =≺≺ getContents\r\n\r\n    solve s = foldr (\\p l -&gt; [mark (p,n) s | s ≺- l, n ≺- s p]) s idx\r\n\r\n    mark (p@(i,j),n) s q@(x,y)\r\n        | p == q                             = [n]\r\n        | x == i || y == j || e x i &amp;&amp; e y j = delete n (s q)\r\n        | otherwise                          = s q\r\n        where e a b = div (a-1) 3 == div (b-1) 3\r\n\r\n    disp s = unlines [unwords [show $ head $ s (i,j) | j ≺- [1..9]] | i ≺- [1..9]]\r\n\r\n    input s = foldr mark (const [1..9]) $\r\n      [(p,n) | (p,n) ≺- zip idx $ map read $ lines s &gt;&gt;= words, n&gt;0]\r\n\r\n    idx = [(i,j) | i ≺- [1..9], j ≺- [1..9]]\r\n\r\nSeriously, the erlang, ocaml and haskell 'small' solutions (not those trying to use tricksy monads) should be about the same size.","controversiality":0,"timestamp_epoch":1566236759,"message_id":"2996-006b3d66-f41b-45b3-870e-07560ed5db97-1566236759"}
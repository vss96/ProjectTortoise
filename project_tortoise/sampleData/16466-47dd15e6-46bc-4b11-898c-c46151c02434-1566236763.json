{"subreddit":"programming","score":9,"ups":9,"author_flair_css_class":null,"created_utc":1165599875,"body":"Haskell even allows infix data constructors...\r\n\r\n    infixl 5 :+\r\n    infixl 6 :*\r\n    infixl 6 :/\r\n    data Exp = Num Integer\r\n             | Var Sym\r\n             | Exp :+ Exp\r\n             | Exp :* Exp  \r\n             | Exp :/ Exp deriving (Eq,Show)\r\n\r\n    data Sym = X | Y | Z deriving (Eq,Show)\r\n\r\n    main = do let exp = (Var X) :* ((Var Y) :+ (Var Z))\r\n              putStrLn $ \"Original expression : \" ++ (show exp)\r\n              putStrLn $ \"Derivative : \" ++ (show (simplify exp))\r\n\r\n    simplify (a :* (b :+ c)) = simplify (a :* b) :+ simplify (a :* c)\r\n    simplify ((a :/ b) :/ (c :/ d)) = simplify (a :* d) :/ simplify (b :* c)\r\n    simplify a = a -- default case \r\n\r\n\r\n...and it is hard to beat the Prolog...\r\n\r\n     simplify(A*(B+C), X+Y) :- simplify(A*B,X), simplify(A*C,Y).\r\n     simplify((A/B)/(C/D), X/Y) :- simplify(A*D,X), simplify(B*C,Y).\r\n     simplify(A,A). \r\n\r\n","controversiality":0,"subreddit_id":"t5_2fwo","link_id":"t3_u4yd","stickied":false,"gilded":0,"distinguished":null,"retrieved_on":1473808098,"author_flair_text":null,"author":"sleepingsquirrel","parent_id":"t3_u4yd","edited":false,"id":"cu54o","timestamp_epoch":1566236763,"message_id":"16466-47dd15e6-46bc-4b11-898c-c46151c02434-1566236763"}
{"author":"KayEss","author_flair_text":null,"id":"cw4jo","edited":false,"parent_id":"t3_w1pv","gilded":0,"distinguished":null,"retrieved_on":1473809453,"body":"A nice article. Our FOST.3 framework does this sort of _uniqueness_ caching, but also adds a couple of features that do affect efficiency neither of which he mentions:\r\n\r\nIt performs lazy fetching of objects from the store. The object is only instantiated into the cache when the object is de-referenced, not when the UID is put into an object reference. I.e. the following line does not hit the database:\r\n\r\n    object_ptr&lt; Page &gt; page( 1234 ); // 1234 is the ID of some page\r\n\r\nBut this one does:\r\n\r\n    page-&gt;type(); // Returns the type object for the page\r\n\r\nIt also performs lazy fetching of attribute data. This also cuts down on database hits as it will never ask for data that isn't used as part of the code path being executed. I.e. this line will fetch the page content from the database in order to return the amount of data:\r\n\r\n    page-&gt;content.size(); // The number of items in the page\r\n\r\nThis also happens when writing changes back to the database, so anything not actually changed does not get written back. Again this helps the SQL server by reducing the load. The application code can commit everything, but the framework will work out what has actually been changed.\r\n\r\nThe importance of the cache in guaranteeing that dereferencing a given object will always hit the correct representation is not to be under-estimated. Without out complex database backed systems get very unreliable very quickly as their size and complexity grow.","controversiality":0,"subreddit_id":"t5_2fwo","link_id":"t3_w1pv","stickied":false,"subreddit":"programming","ups":1,"score":1,"author_flair_css_class":null,"created_utc":1167202832,"timestamp_epoch":1566236778,"message_id":"52501-dde41015-faa5-465e-bf7a-1db23c2c7663-1566236778"}
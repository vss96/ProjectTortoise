{"controversiality":0,"body":"I was trying to clarify the original point of the article, which feijai and several others seem to be missing: that OS environments not originally designed to support high-level languages place a burden on high-level language implementations to function in that environment. That argument applies to Common Lisp, but also to other languages like Java, Python, Ruby, and lots of other candidates for new languages.\r\n\r\nTo choose just one example, the desire of high-level languages to support automatic memory management through garbage collection. All a UNIX-oid kernel does is allow you to grab large chunks of undifferentiated memory for a process (possibly shared with another process, or mapped to a file), and sometimes, you can give it back when you are done. \r\n\r\nIf you want to use that for a high-level language like CL, you typically want to fill that memory with tagged objects so you can properly identify the sizes and locations of many small objects like CONS cells, and that establishes invariants that must be preserved for your GC not to break. \r\n\r\nWill the OS accept tagged objects or pass them back to you? NO. Everything is unboxed machine integers, or blocks of undifferentiated bytes. Every system call involves some penalty for unboxing and reboxing.\r\n\r\nDoes the OS environment help to keep those invariants? NO. It can interrupt you in the middle of a GC operation, meaning if you want a multi-threaded process, the GC operations have to use other synchronization mechanisms. \r\n\r\nDoes the OS environment provide a common substrate so that independent high-level languages can put tagged objects in shared memory and have them make sense to one another? NO. My tagged objects have to be re-encoded into some other format to pass to another language. Probably a lowest-common-denominator unboxed format, which the receiving process has to re-box. Or I have to pin objects so my GC doesn't move them, because nothing else on the machine follows my GC discipline.\r\n\r\nThat Java has to use virtual machines and JIT compilers to get decent performance is just one example of a strategy to deal with this mismatch. They may run \"good enough\" or even \"run great\" but they don't run as well as they might. The mismatch is there.\r\n\r\nHigh performance of languages like Haskell and OCaml is, AFAIK, when the problem description is constrained enough to function within a C-like environment, and the compiler is able to infer enough to operate with unboxed quantities in registers. In principle, Lisp can do the same using, for example, specialized arrays laid out in machine native unboxed formats; however, most Lisp programs don't provide enough type information or remain within type discipline well enough to achieve this in practical benchmarks.","stickied":false,"link_id":"t3_tksn","subreddit_id":"t5_2fwo","subreddit":"programming","created_utc":1165333746,"author_flair_css_class":null,"score":4,"ups":4,"author_flair_text":null,"author":"sickofthisshit","id":"ctpeg","edited":false,"parent_id":"t1_cto4s","gilded":0,"retrieved_on":1473807806,"distinguished":null,"timestamp_epoch":1566236760,"message_id":"9078-bab55ab2-ba3d-48ec-891d-34fcfed949f7-1566236760"}
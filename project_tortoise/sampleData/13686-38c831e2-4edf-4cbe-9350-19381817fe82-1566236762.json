{"gilded":0,"distinguished":null,"retrieved_on":1473807989,"author_flair_text":null,"author":"nostrademons","id":"ctz55","edited":false,"parent_id":"t1_ctz0t","subreddit":"programming","score":12,"ups":12,"author_flair_css_class":null,"created_utc":1165499339,"body":"I think the same way.  However, the advantage of FP comes when you start composing chunks of building blocks.  For example, what if the two functions had been:\r\n\r\n    map someComplexFunctionThatClosesOverManyVariables list\r\n    map someComplexFunctionThatClosesOverManyVariables $ reverse list\r\n\r\nvs.\r\n\r\n    for(int i = 0; i &amp;lt; list.size(); i++) {\r\n       // Some complex calculation that closes over many variables\r\n    }\r\n    for(int i = list.size - 1; i &gt;= 0; i--) {\r\n       // Some complex calculation that closes over many variables\r\n    }\r\n\r\nIn the Haskell case, I can easily chunk this is as a single operation applied both to a list and its reverse (if it's stateless, I could even do the reverse after computing it, but let's not make that assumption).  In the Java, I have to treat it as two separate loops, because the cost of factoring out the common expression is greater than the cost of duplicating it.","controversiality":0,"subreddit_id":"t5_2fwo","link_id":"t3_twtt","stickied":false,"timestamp_epoch":1566236762,"message_id":"13686-38c831e2-4edf-4cbe-9350-19381817fe82-1566236762"}
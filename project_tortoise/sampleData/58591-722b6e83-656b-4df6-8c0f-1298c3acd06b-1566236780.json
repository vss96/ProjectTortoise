{"score":0,"ups":0,"created_utc":1167483909,"author_flair_css_class":null,"subreddit":"programming","subreddit_id":"t5_2fwo","stickied":false,"link_id":"t3_wcxk","controversiality":0,"body":"Caching is both simple and difficult. If I have a query, sometimes it's better to fetch the whole dataset doing queries on client side, sometimes it's better do to a 'real' query each time, often it's something in between. And without compiler support this always has to implemented again (latently typed languages have a big advantage here). \r\n\r\nBut the main problem with caching is invalidating the cache, it can be quite difficult to decide this properly: Miss a single reason which can invalidate a cache can lead to really hard to find errors.\r\n\r\nBut caching is OTOH relatively easy, it's mainly the amount of work and the risk to forget something. Especially if you have a big project with lots of dependencies. So I believe that its perfect for let it be done by the compiler.\r\n\r\nThe next step would be to put relations (which are in principle not more than sets of tuples) directly as first class data type into the language. Then we could use those relations directly as base for our code and work with them without even thinking about if they are in-memory structures or if they reside in a SQL server. It's simply the other-way-around: Instead of converting data from the DB into objects, work directly with relational algebra instead of objects. Relational algebra is in principle the more powerful technique to structure data so why not use it in client code instead of the less powerful object model?\r\n\r\n","distinguished":null,"retrieved_on":1473809676,"gilded":0,"id":"cwgdy","parent_id":"t1_cwfin","edited":false,"author":"kawa","author_flair_text":null,"timestamp_epoch":1566236780,"message_id":"58591-722b6e83-656b-4df6-8c0f-1298c3acd06b-1566236780"}
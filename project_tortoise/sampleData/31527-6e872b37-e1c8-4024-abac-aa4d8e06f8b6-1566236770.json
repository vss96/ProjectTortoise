{"retrieved_on":1473808658,"distinguished":null,"gilded":0,"parent_id":"t3_uuzg","id":"cuyvi","edited":false,"author_flair_text":null,"author":"doubtingthomas","created_utc":1166220711,"author_flair_css_class":null,"score":2,"ups":2,"subreddit":"programming","stickied":false,"link_id":"t3_uuzg","subreddit_id":"t5_2fwo","body":"One element of syntax that this article and people in general don't seem to address is how well it maps to the actual execution model of the machine.\r\n\r\nThis is a fairly important factor for me. I really enjoy haskell, but I'm reluctant to run use it for any production critical system because what you type and what the computer actually does aren't that closely related. Laziness and bad-ass abstractions (and things like rewrite rules) mean that I'm more specifying a result than a process. In most situations, I consider this to be a benefit, but in a mission-critical situation, I prefer to be able to reasonably mentally translate what I type to what the computer (or virtual machine) does. \r\nI'm sure some people can do it, but nobody denies that reasoning about lazy evaluation is tricky tricky.\r\n\r\nSo, while I'm strongly in favour of syntax that clearly illustrates what the intention of the code is and what the result of the code is, I think that it should also clearly indicate how it will happen. I don't know if this contradicts my love of good abstractions, and of course what is considered intuitive changes (i imagine an old-school C programmer would be confounded by ruby or ML if they hadn't manually implemented such abstractions themselves before). \r\n\r\n\r\nAlso, a fun thought: \"Every Lisp macro is the result of a deficiency in the language.\"\r\n\r\n(Of course, that's not quite right because the idea that people get to make their own little language with macros is a part of Lisp, so the 'deficiency' could be just considered a design choice.)","controversiality":0,"timestamp_epoch":1566236770,"message_id":"31527-6e872b37-e1c8-4024-abac-aa4d8e06f8b6-1566236770"}
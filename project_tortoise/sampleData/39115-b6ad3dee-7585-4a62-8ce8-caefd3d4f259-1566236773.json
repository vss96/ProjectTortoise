{"author_flair_text":null,"author":"cashto","parent_id":"t1_cvbnk","id":"cvee1","edited":false,"gilded":0,"retrieved_on":1473808951,"distinguished":null,"body":"&gt;2) Write: Constructor, Copy Constructor, Assignment Operator, Destructor... REPEAT!\r\n\r\nActually, the rule is, \"if you write one of them, you should write all of them\".  But no one says you HAVE to implement any of them.  I typically don't.  I typically rely on the compiler's autogenerated version - that's because I try to avoid objects that contain raw pointers and have shallow-copy semantics.\r\n\r\n&gt;Wait... when do I stop worrying about managing my heap memory and exception safety and thread safety and temporaries and const correctness and v-table size and start getting real work done?\r\n\r\nAlthough you can't program in C++ without knowing many of these concepts, once mastered, I don't really spend a lot of time worrying about them -- RAII covers a lot of resource management / exception safety, const correctness is really a useful programming aid, v-table and temporaries are just concepts in optimization, and thread-safety: well, thread safety you just have to deal with in any language that supports shared memory concurrency (ie, every language but Erlang).  :-)\r\n\r\n&gt;1) Everything is a list. Sorry, you're talking to a guy who sees a linked list as an instant sign that you are looking at bad code. Is there a worse data structure in the universe?\r\n\r\nYes.  Fixed-sized arrays.  :-)\r\n\r\nTo be fair, I see your point.  I often prefer vector to list.  I like random access and less memory overhead.  It bugs me that Erlang implements strings as lists of integers, requiring 8 bytes per character.  That said, it amazes me how fast Erlang can be even though (apart from tuples) \"everything is a list\".  I'm impressed with the elegance that single-assignment, in conjunction with lists, makes garbage collection unnecessary.\r\n\r\n&gt;2) If you write functions with no side effects, programs can be proven to be true mathematically. OK, it's not the concept that sucks, it's that it never seems to have done anyone any good! Who here has proved a program?\r\n\r\nThis is definitely an overhyped \"benefit\" of functional languages.  But the sentiment isn't far from the truth.  Side effects *are* bad.  Avoiding them *is* good.  Avoiding them *completely* is impossible -- after all, an application without any side effects is an application that does nothing.  But there's still a lot of sense in discouraging them or disallowing them in the general case.","controversiality":0,"stickied":false,"link_id":"t3_v6rx","subreddit_id":"t5_2fwo","subreddit":"programming","created_utc":1166558342,"author_flair_css_class":null,"score":3,"ups":3,"timestamp_epoch":1566236773,"message_id":"39115-b6ad3dee-7585-4a62-8ce8-caefd3d4f259-1566236773"}
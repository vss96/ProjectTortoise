{"author_flair_css_class":null,"created_utc":1165026368,"ups":43,"score":43,"subreddit":"programming","link_id":"t3_t9zb","stickied":false,"subreddit_id":"t5_2fwo","controversiality":0,"body":"That code is extremely clever. Net net as I understand it: this is a great hack that picks an awesome initial value for Newton's approximation method. It essentially takes the inverse square root (negates and divides the exponent) without using multiplication or division, which are expensive operations.\r\n\r\nMy thoughts:\r\n\r\n1. Newton's method can be used to find approximate roots of any function. You can keep iterating, but in this case they did it in 1 step!\r\n\r\n[Geek side note: if you have a function f(x) and want to find its root (let's call your initial guess \"g\"), gnew = g - f(g)/f'(g)\r\n\r\nIn the case of f(x) = 1/x^2 - i (where i is the initial value and you are trying to minimize the difference, ie., make f(x) = 0 for your guess of x, aka find the root :-) ), gnew = g(1.5 - i*g^2).\r\n\r\nSo, if you get a \"gnew\" and keep plugging it into the equation, you'll get closer and closer to the answer.]\r\n\r\nHere is a demo of multiple iterations to find inverse square: http://tinyurl.com/vh7hg\r\n\r\nTry plugging in different initial guesses (.2, .4, .8) to see how it converges.\r\n\r\n2. So, the problem becomes \"how can we make a good initial guess?\"\r\n\r\nWell, our best guess for the inverse square root is the inverse square root itself! How do you get 1/sqrt(n)?\r\n\r\nThis is where the magic comes in. Assume you have a number in exponent form:\r\n\r\n10^6 = 1 million\r\n\r\nIf you want to find the regular square root, just divide the exponent by 2. so sqrt(10^6) = 10^(6/2) = 10^3 = 1 thousand.\r\n\r\nIf you want the *inverse* square root, divide the exponent by -2 to flip the sign. So invsqrt(10^6) = 10^(6/-2) = 10^-3 = 1/thousand\r\n\r\nFloats are stored in mantissa-exponent form, so it's possible to divide the exponent! \r\n\r\nBut instead of explicitly doing division (expensive), the code uses another clever hack: shifting bits is the same as dividing by two (or four, or 16, or any power of 2; it will truncate the remainder though). And if you want to get a negative number, instead of multiplying by -1 (multiplications are expensive), just subtract it from \"0\" (cheap).\r\n\r\nSo, it converts the number into an integer and shifts the bits, which means the exponent is shifted if you convert it back into a float. It subtracts from the magic number 0x5f37... to preserve the mantissa, handle odd-even exponents, shifting bits from the exponent _into_ the mantissa, and all sorts of funky stuff. Read the paper for more details, I didn't catch all of it the first time around.\r\n\r\nAnyway, the result is an initial guess that is really close to the real inverse square root! You can then run a round of Newton's method to refine the guess. One round is all that's really needed for the precision desired.\r\n\r\n3. Why the magic number?\r\n\r\nThe great hack is how integers and floating point numbers are stored. floating point numbers store their exponent (like 10^6 above). When you shift the bits you are shifting the exponent (dividing by 2). You are also shifting the value of the number (like 5 * 10^6), but that's where the magic number comes in - it does some cool corrections for this that I don't quite understand.\r\n\r\nAnyway, net is that subtracting from the magic number halves the exponent and makes it negative (doing the inverse square root) while not damaging the mantissa as they say. The magic number also corrects for even/odd exponents; the paper mentions you can also find other magic numbers to use.\r\n\r\nReally clever!","retrieved_on":1473807536,"distinguished":null,"gilded":0,"id":"ctb12","edited":false,"parent_id":"t3_t9zb","author_flair_text":null,"author":"pb_zeppelin","timestamp_epoch":1566236759,"message_id":"2674-44ca0a97-4a03-49aa-803d-a1e3ad8642eb-1566236759"}
{"controversiality":0,"body":"Well, to a first approximation, you could think of a webserver as a function from HTTP requests to actions to be performed in order to construct a page with which to respond to the user. Those actions may have side effects (in anything more complex than static page servers), but the function which builds them need not have any. This is a somewhat nice distinction to make, as the level of referential transparency in the responses will be made completely clear. Any action which wishes to do something different based on state will have to explicitly pull in a state variable from somewhere, which looks very different from getting a function parameter. Also, ordinary evaluation doesn't cause any side effects -- all the actions which are composed by the function are somewhat akin to code which is interpreted by another function and which can check various consistency properties as it executes it.\r\n\r\nCheck out [HAppS](http://happs.org/HAppS/README.html) which is a good example of using a monad in order to enforce [ACID](http://en.wikipedia.org/wiki/ACID) properties.\r\n\r\nThe point is, functional languages don't completely discourage state when it's really the right model for things, but functional programmers tend to be really quite picky when they're going to use it at all about how nicely the abstraction is implemented -- how many checks and assurances are in place that the variables being threaded through a computation will not have things done to them which put them in an inconsistent state.\r\n\r\nAs a vast generalisation of imperative programming (extending quite often to the point where it no longer appears to be imperative programming), monadic programming allows one to do everything that one might do in an imperative language, but to build in additional safety requirements.\r\n\r\nAs for whether state really is the right model, well, perhaps not for all applications, but it seems that it's an at least halfway decent way to deal with the need to manage persistence in the face of a stateless protocol. Some applications might work out better with some form of stream-based interface, where certain streams are opened up at the beginning of the program, and read from and written to in a roughly FIFO manner.\r\n\r\nAnother, rather different approach is to use continuations to manage the future of user sessions. This is an approach taken by [WASH](http://www.informatik.uni-freiburg.de/~thiemann/haskell/WASH/)  and perhaps more famously, the [PLT Scheme](http://www.plt-scheme.org/) [web server](http://download.plt-scheme.org/doc/360/html/web-server/)\r\n\r\nIt allows one to treat entire user sessions as single continuous programs without having to manage restoring the session state and future of the computation by hand every step of the way. [Shriram Krishnamurthi](http://www.cs.brown.edu/~sk/) has a [rather good video of a talk given to Microsoft](http://download.microsoft.com/download/9/4/1/94138e2a-d9dc-435a-9240-bcd985bf5bd7/Shriram.wmv) regarding this technique and some of the more recent stuff which he's been working on for ajax, in which he tries very hard to pretend not to love functional and declarative programming.","subreddit_id":"t5_2fwo","link_id":"t3_uhdn","stickied":false,"subreddit":"programming","score":2,"ups":2,"author_flair_css_class":null,"created_utc":1165891507,"author_flair_text":null,"author":"cgibbard","id":"cuinf","parent_id":"t3_uhdn","edited":false,"gilded":0,"distinguished":null,"retrieved_on":1473808356,"timestamp_epoch":1566236767,"message_id":"23891-03717129-f25e-4cab-b11d-8daf16593295-1566236767"}
{"gilded":0,"distinguished":null,"retrieved_on":1473807682,"author_flair_text":null,"author":"cgibbard","id":"ctiq5","edited":false,"parent_id":"t3_tif6","subreddit":"programming","score":20,"ups":20,"author_flair_css_class":null,"created_utc":1165213423,"body":"I think the biggest feature that I'd want in a programming language is a knowledgeable designer.\r\n\r\nFor example, Python is a fairly nice OO language, but some of the things which GvR has said regarding functional languages are just inexcusably uninformed things for a language designer to be saying.\r\n\r\nHow can one hope to improve the situation with programming languages if one doesn't have a firm grasp of the features which existing languages have?\r\n\r\nSome specific things which I think it would be important to be comfortable with, aside from mainstream programming:\r\n\r\n0. Type theory in general! Read TAPL and ATTAPL. Even if you're going to implement a dynamically typed language, be sure that there's a good reason why you're doing that.\r\n1. Typeclasses (as in Haskell/Clean) and/or SML style modules.\r\n2. Monads, Monad transformers, Hughes' Arrows, Comonads (these are not exactly language features, but they do provide nice ways of embedding languages and implementing compilers and interpreters, and being comfortable with them means that you probably won't be as likely to construct a crippled language.)\r\n3. Prolog/Mercury-style nondeterminism.\r\n4. Smalltalk-style OO. This will also give you some idea of the possibilities inherent in making the language and execution environment more closely related. For a functional take on this, perhaps check out [Subtext](http://subtextual.org/).\r\n5. Evaluation mechanisms - you want to be able to make an informed decision about whether to use strict evaluation, or whether it's worth it to support non-strict semantics somehow (either with lazy evaluation, or some more eager mechanism). Of course, this is also tied in with considerations regarding the potential for nondeterminism.\r\n6. Coroutines. Everyone reinvents these, and they're again tied to the whole execution/evaluation model.\r\n\r\nEven if your language is not going to have anything like any of these things, it's useful to know what's out there, so you don't end up redesigning the wheel. It's also useful to know about things which were considered mistakes, and why. For instance, dynamic scoping would be one of these mistakes.\r\n\r\nScoping in general is quite a tricky thing to get right, especially in the presence of mutable state, and it's really a more important thing than most people give it credit for. Ruby and Python both have some subtle issues with scoping and mutation which it may be too late to fix. I was talking with someone just tonight about how some scoping rules in Ruby really make it impossible for metaprogramming to be about twice as elegant as it is.\r\n\r\nAnyway, I really do think that knowledge of a lot of other designs goes a long way, regardless of which features you end up putting into your language.","controversiality":0,"subreddit_id":"t5_2fwo","link_id":"t3_tif6","stickied":false,"timestamp_epoch":1566236760,"message_id":"6083-cb9b82bc-4aac-48ca-8908-44f555d049ea-1566236760"}
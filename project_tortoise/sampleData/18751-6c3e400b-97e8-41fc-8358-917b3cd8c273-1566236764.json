{"distinguished":null,"retrieved_on":1473808175,"gilded":0,"parent_id":"t1_cu69p","id":"cu95i","edited":false,"author":"ubernostrum","author_flair_text":null,"score":4,"ups":4,"author_flair_css_class":null,"created_utc":1165688650,"subreddit":"programming","subreddit_id":"t5_2fwo","link_id":"t3_u2mr","stickied":false,"body":"Well, generally the multi-paradigm thing comes up when someone says that Language X is the One True Platonic Ideally Pure implementation of OO, and Python folks come back with \"practicality beats purity\". Being the Platonic form of OO or FP or whatever paradigm someone's pushing is great when 100% of your programming tasks are in the domain of that paradigm, but starts sucking pretty hard otherwise ;)\r\n\r\nAnd despite the marketing tagline, Python is pretty agnostic about how you program; you can be imperative, functional, OO, or none of the above. Often all in the same program (though this may not be the best thing to do). Under the hood it is OO, but it doesn't get up in your face about the OO stuff and force you to adapt your programs to that -- unlike, for example, C# and Java, you're allowed to write standalone imperative code that never explicitly mentions classes or methods. Unlike Ruby, you're allowed to treat a callable as a callable, instead of jumping through hoops to get references to the things-that-Ruby-calls-methods-but-are-really-message-names. Etc.","controversiality":0,"timestamp_epoch":1566236764,"message_id":"18751-6c3e400b-97e8-41fc-8358-917b3cd8c273-1566236764"}
{"controversiality":0,"body":"In Ruby and most likely in other languages since I'd be surprised if this is without prior art, `42.times` is a fast way to replace the standard `for(i = 0; i &lt; 42; i++)` when you don't need `i`. (This, when coupled with a rich IEnumerable, covers almost eliminates the use of a for-loop.) Indeed, [there is a rich Integer class in Ruby](http://ruby-doc.org/core/classes/Integer.html) and many other libraries build upon this.\r\n\r\nOf course, for each method I could pick from Ruby's Integer class and throw at Python, there's an equally hip Pythonic way to achieve the task. But in the context of defending Python as a multi-paradigm language that's strong on OO, any non-OO alternative, while valid in general, isn't necessarily valid in this context. So while accessing methods on numbers may be un-Pythonic, having to work around Python's float syntax to call those is un-OO, and certainly is a difficult design decision to justify if indeed OO was a core feature from the get-go.","stickied":false,"link_id":"t3_u2mr","subreddit_id":"t5_2fwo","subreddit":"programming","created_utc":1165628705,"author_flair_css_class":null,"score":1,"ups":1,"author":"markedtrees","author_flair_text":null,"edited":false,"id":"cu6ym","parent_id":"t1_cu5g8","gilded":0,"retrieved_on":1473808136,"distinguished":null,"timestamp_epoch":1566236763,"message_id":"17582-6166fe04-adac-4c2f-99ed-f2a7f455425b-1566236763"}
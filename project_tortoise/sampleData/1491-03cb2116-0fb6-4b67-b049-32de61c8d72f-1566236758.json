{"retrieved_on":1473807497,"distinguished":null,"gilded":0,"parent_id":"t1_ct8ju","edited":false,"id":"ct8x2","author_flair_text":null,"author":"nostrademons","created_utc":1164992897,"author_flair_css_class":null,"ups":5,"score":5,"subreddit":"programming","stickied":false,"link_id":"t3_t7v9","subreddit_id":"t5_2fwo","body":"But consider this Haskell:\r\n\r\n    class C a where method :: a -&gt; Int\r\n    data D = ...\r\n    data E = ...\r\n    instance C D where method = const 2\r\n    instance C E where method = const 3\r\n\r\n    foo :: (C a) =&gt; a -&gt; Int\r\n    foo x = method x\r\n\r\nWhen foo is called, what's returned?  Well, it depends - at run time - whether it was called with a D or an E.  If called with a D, it returns 2.  If called with an E, it return 3.  Yet most people would consider Haskell to be statically typed.\r\n\r\nThe presence of ad-hoc polymorphism does not, in itself, make a language dynamically typed.\r\n\r\nC++ and Java are dynamically typed for a different reason: the casts.  They let you completely circumvent the type system at runtime and pretend that an object is something that it's not.","controversiality":0,"timestamp_epoch":1566236758,"message_id":"1491-03cb2116-0fb6-4b67-b049-32de61c8d72f-1566236758"}
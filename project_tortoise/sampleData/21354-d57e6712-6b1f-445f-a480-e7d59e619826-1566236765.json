{"distinguished":null,"retrieved_on":1473808265,"gilded":0,"parent_id":"t1_cudrr","edited":false,"id":"cudwv","author_flair_text":null,"author":"not_fark_or_digg","ups":3,"score":3,"author_flair_css_class":null,"created_utc":1165806233,"subreddit":"programming","subreddit_id":"t5_2fwo","link_id":"t3_uc0l","stickied":false,"controversiality":0,"body":"Are you talking about the hashmap? That's part of the point, that for the most part a hashmap can be updated independently by several threads. However collisions /are/ possible. Light-contention is where STM does best; it optimistically assumes there's no contention and goes ahead, and rolls back if it detects that there was, afterall. \r\n\r\nWhen contention is high enough (from some other paper, see Lambda the Ultimate for lots of them), straight-ahead locking will beat it because STM has the overhead of setup and extra copying. \r\n\r\nBut the article above's point was, that the easiest way to protect the hashmap was to lock the object totally, (which yielded flat performance) and for similar programming effort (in some future language) STM scales with processors.","timestamp_epoch":1566236765,"message_id":"21354-d57e6712-6b1f-445f-a480-e7d59e619826-1566236765"}
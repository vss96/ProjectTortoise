{"distinguished":null,"retrieved_on":1473808761,"gilded":0,"parent_id":"t1_cv3ya","edited":false,"id":"cv492","author_flair_text":null,"author":"kalmar","score":4,"ups":4,"author_flair_css_class":null,"created_utc":1166372796,"subreddit":"programming","subreddit_id":"t5_2fwo","link_id":"t3_v34f","stickied":false,"controversiality":0,"body":"&gt; i may assume that wrapping my call with a Maybe return type will do the trick, but being a newbie, i'm in very weak position to start working with assumptions.\r\n\r\nI believe that would do it.  The type of `lookup` is `(Ord k, Monad m) =&gt; k -&gt; Data.Map.Map k a -&gt; m a`.  The `Ord k` constraint is just the usual requirement that the keys be ordered.  The `Monad m` constraint is the interesting one: the compiler will allow any `Monad` instance here.  The implementation of `lookup` will `return` the value at the key if the key is in the `Map`, or else it will `fail`.  In the `Maybe` monad, `fail msg = Nothing`; in the list monad, `fail msg = []`, in the IO monad, `fail msg = error msg`.\r\n\r\nSo, from the context in which you use `lookup`, the correct behaviour will be chosen.  At compile time, mind.  This is a Haskell pattern called \"Not Just Maybe\": if a function could return a result of type `a` or fail to do so, it is sometimes useful to go past the usual `Maybe a` type for the return to a general monad.  I can't find the wiki page on it though, which is unfortunate.  There were a bunch of useful patterns on there.","timestamp_epoch":1566236771,"message_id":"33968-3458022d-d88b-4996-aa75-3984b75c7a13-1566236771"}
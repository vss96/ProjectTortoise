{"controversiality":0,"body":"I can't help but bite, since this should be much easier. Here is a one-liner:\r\n\r\n    CAStep[rule_, a_] := rule[[ 8 - (RotateLeft[a] + 2 (a + 2 RotateRight[a])) ]] \r\n\r\nLet me show how this works, starting backwards from the result, in 3 simple steps.\r\n\r\n#### Step 1: Extracting the bits out of the cellular automaton rule\r\n\r\n\"rule\" represents the CA rule as a list of bits, say {0, 0, 0, 1, 1, 1, 1, 0} for rule 30.\r\n\r\nIn Mathematica, [[ ]]  notation for indexing into lists (or any other expression)::\r\n\r\n    {0, 0, 0, 1, 1, 1, 1, 0}[[ 4 ]] --&gt; 1\r\n\r\nand, you can index a set of elements at once:\r\n\r\n    {0, 0, 0, 1, 1, 1, 1, 0}[[{1,2,3,4}]] --&gt; {0,0,0,1} \r\n\r\nSo now our task has been reduced to converting the list of cells into the appropriate list of indices.\r\n\r\n(to reduce suspense, the initial condition {0,0,1,0,0} will correspond to the list of indices {8,4,6,7,8} )\r\n\r\n#### Step 2: Taking a neighborhood and generating an index\r\n\r\nEach ca cell has a neighborhood {leftcell, selfcell, rightcell} . We can take that triplet of base-2 bits and convert it into a single number using the formula:\r\n\r\n    index = 8 - rightcell + 2 (selfcell + 2 leftcell)\r\n\r\nFor example, if we want to update the middle cell in {0,0,1,0,0}, its index will be\r\n\r\n8 - 0 + 2*(1 + 2**0)  --&gt; 6,  and if we extract the sixth part of the rule bits\r\n{0, 0, 0, 1, 1, 1, 1, 0}[[6]] --&gt; 1\r\nand we confirm that the cell become black under rule 30.\r\n\r\n#### Step 3: Do it all at once, for all cells. (This is the fun part.)\r\n\r\nIn Mathematica mathematical operations are auto-vectorized when possible. So the formula\r\n\r\n    index = 8 - rightcell + 2 (selfcell + 2 leftcell)\r\n\r\nwill just automatically work if rightcell,selfcell, and leftcell were in fact lists of cells rather than individual cells.\r\n\r\nSo how do we get these lists? Well list of selfcells is already provided to us: it is exactly the initial condition.\r\n\r\nTo get the list of leftcells and rightcells, we simply rotate the the original list:\r\n\r\n    RotateRight[{0,0,1,0,0}] --&gt; {0,0,0,1,0}\r\n    RotateLeft[{0,0,1,0,0}] --&gt; {0,1,0,0,0}\r\n\r\n#### RECAP:\r\n\r\nFirst we rotate the neighorhoods so that they align correctly:\r\n\r\n    8 - (RotateLeft[{0,0,1,0,0}] + 2 ({0,0,1,0,0} + 2 RotateRight[{0,0,1,0,0}]))\r\n    8 - ({0,0,0,1,0} + 2 ({0,0,1,0,0 } + 2 {0,1,0,0,0})\r\n\r\nNext we calculate the appropriate indices for each cell:\r\n\r\n    8 - ({0,0,0,1,0}+ {0,0,2,0,0} + {0,4,0,0,0}\r\n    8 - {0,4,2,1,0}\r\n    {8,4,6,7,8}\r\n\r\nFinally we select the appropriate bits of the rule:\r\n\r\n    {0, 0, 0, 1, 1, 1, 1, 0}[[{8,4,6,7,8}]]\r\n    {0, 1, 1, 1, 0 }\r\n\r\nand we are done!\r\n\r\nOh, and evolving it over and over?\r\n    NestList[CAStep[rule,#]&amp;,init,steps]","link_id":"t3_vc6i","stickied":false,"subreddit_id":"t5_2fwo","subreddit":"programming","author_flair_css_class":null,"created_utc":1166558409,"score":0,"ups":0,"author":"programnature","author_flair_text":null,"edited":false,"id":"cvee9","parent_id":"t3_vc6i","gilded":0,"retrieved_on":1473808951,"distinguished":null,"timestamp_epoch":1566236773,"message_id":"39120-883de0f9-9734-49d1-baa1-b4bf402f5c8f-1566236773"}
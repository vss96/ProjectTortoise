{"gilded":0,"distinguished":null,"retrieved_on":1473807792,"author":"pjdelport","author_flair_text":null,"id":"cton0","edited":false,"parent_id":"t1_ctoke","subreddit":"programming","score":3,"ups":3,"author_flair_css_class":null,"created_utc":1165322037,"body":"Uh, you can write it using (first-class higher-order) functions in Python too;  that's exactly what was done before decorator syntax was introduced.\r\n\r\nDecorators are nothing more than a completely optional syntactical convenience for a particular kind of wrapping.  They let you write this:\r\n\r\n    def foo(...):\r\n        ...\r\n    foo = decorate(foo)\r\n\r\nmore readably as this:\r\n\r\n    @decorate\r\n    def foo(...):\r\n        ...\r\n\r\n(where `decorate` can also be an expression like `annotate(foo=bar)`).\r\n\r\nThe article seems to confuse decorator syntax, which is new, with function wrapping in general, which has always been in Python.\r\n\r\nActually, i'm not sure what the article understands at all, given nonsensical comments like:\r\n\r\n&gt; The very first thing that comes to mind is decorating destroys manifest interface. You can no longer examine a piece of code and examine the type signature of the functions it calls and know what is supposed to happen.\r\n\r\nWrapping a function in Haskell obviously doesn't destroy any type information;  higher-order functions would be utterly impractical otherwise.","controversiality":0,"subreddit_id":"t5_2fwo","link_id":"t3_to4r","stickied":false,"timestamp_epoch":1566236760,"message_id":"8764-1c86fa85-08fa-4a89-9d35-e890a661ec94-1566236760"}
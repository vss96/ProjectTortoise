{"subreddit":"programming","author_flair_css_class":null,"created_utc":1166313580,"score":5,"ups":5,"controversiality":0,"body":"&gt; I would've first created an abstraction (which would cost about 15 lines) and then create a specialized solution to the problem (which would cost about 5 lines)\r\n\r\nSee, that's what he was expecting, and that's precisely what I *didn't* do.  Got me a book though, so I'm not complaining. :-)\r\n\r\nHere's a common saying about computer programmers: \"When asked to hammer in a nail, they will create a machine that takes an XML spec for any kind of pointed projectile, fashions a user-configurable number of them, uses them to construct an automatic fully-configurable projectile-driver with settings for one hundred different surfaces, and then finally invokes the projectile-driver to hammer in the nail.\"  I'm saying that maybe we shouldn't do that, and maybe sometimes, *you really just oughtta hammer the nail*.  Chances are, you will be doing 99% of your work with hammers and nails, and so the ridiculous amount of time you save by taking the easy solution there gives you tons of extra time to work out a platform for the really difficult problems.\r\n\r\nHeck, we're up to our eyeballs in platforms at my workplace, and as far as I can tell, very few of them actually solve problems that didn't exist before the framework was created.\r\n\r\nAnyway, this is all beside's Coffeemug's point, which is that when you *do* need to create that abstraction, Haskell gives you many more ways to do so.  So in his example, you've already got the abstraction (listify) and each new specialized solution is about 2 lines.","link_id":"t3_uzuc","stickied":false,"subreddit_id":"t5_2fwo","gilded":0,"retrieved_on":1473808725,"distinguished":null,"author_flair_text":null,"author":"nostrademons","id":"cv2ct","edited":false,"parent_id":"t1_cv2ai","timestamp_epoch":1566236770,"message_id":"33024-907ce138-05c3-4806-b9e5-39de6afeae8c-1566236770"}
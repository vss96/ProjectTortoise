{"retrieved_on":1473808623,"distinguished":null,"gilded":0,"edited":false,"id":"cux1k","parent_id":"t1_cuwq9","author_flair_text":null,"author":"nostrademons","created_utc":1166196983,"author_flair_css_class":null,"score":6,"ups":6,"subreddit":"programming","stickied":false,"link_id":"t3_utqb","subreddit_id":"t5_2fwo","body":"Well, yes.  But that's largely because Haskell has had 15+ years of development by very smart people without the curse of backwards compatibility.  Java has had 15 years or so of development, but it went public after only about 4, and so the remaining 10 years have involved very little progress.\r\n\r\nWart-wise, Haskell looks very similar to where Java was in 1996.  I picked up Java with version 1.0.2, and it looked like a very, very clean language.  They fixed several of the pain points of C++ outright (GC, built-in documentation, decent packaging system), cleaned up the syntax and semantics, and put everything into a fairly elegant framework.\r\n\r\nUnfortunately, it's basically stayed the way it was in 1996, with a few nifty fixes like generics, autoboxing, and enums.  Meanwhile, Python &amp; Ruby got closures, list comprehensions, and all sorts of other conveniences.  And Java expanded into the domains that *needed* operator overloading and platform-specific features and control over allocation, and its simplicity doesn't look so simple there.\r\n\r\nHaskell does have the advantage of having some genuinely new ideas about computation (arrows, GADTs, other type-system enhancements, etc.), while Java was mostly a rehash of 1970s technology.  But most of them probably can't go into the standard if we want Haskell to be popular.  It's hard enough to explain monads to a Java/Python programmer; try extending that to arrows.","controversiality":0,"timestamp_epoch":1566236769,"message_id":"30589-9eace5c4-fe54-42a6-8406-7d11109a5b62-1566236769"}
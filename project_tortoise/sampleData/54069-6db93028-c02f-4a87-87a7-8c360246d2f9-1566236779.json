{"body":"This blog post raises a very interesting question, which I've thought about myself when writing in Haskell: what if every function was of type `a -&gt; m b` (i.e., every arrow was a kleisli arrow)?  You can define an \"identity monad\" for pure functions:\r\n\r\n    data Identity a = Identity a\r\n    \r\n    instance Monad Identity where\r\n      return              = Identity\r\n      (Identity a) &gt;&gt;= f  = f a\r\n\r\nWe can redefine function composition to work in any monad:\r\n\r\n    (.) :: (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; a -&gt; m c\r\n    (.) f g x  = g x &gt;&gt;= f\r\n\r\nAnd so on with the rest of the standard library.  This can all be done in regular Haskell, with a bit of work.  Now when some part of our code that used to be pure needs to have side-effects (which does happen occasionally), only the types will change -- not the code itself.\r\n\r\nNow, if we want to redefine function application (e.g., `f (g x)`) to do the right thing, we'd have to modify the language a bit.  But such a redefinition may actually be a good thing.  An extremely common newbie mistake is to write something like `putStrLn (\"You typed \" ++ getLine)`.  In our new Haskell, this would actually work.  Of course, this would require every function to have some standard evaluation order for its arguments.","controversiality":0,"subreddit_id":"t5_2fwo","stickied":false,"link_id":"t3_w79v","subreddit":"programming","score":7,"ups":7,"created_utc":1167267625,"author_flair_css_class":null,"author":"panic","author_flair_text":null,"edited":false,"id":"cw7dw","parent_id":"t3_w79v","gilded":0,"distinguished":null,"retrieved_on":1473809509,"timestamp_epoch":1566236779,"message_id":"54069-6db93028-c02f-4a87-87a7-8c360246d2f9-1566236779"}
{"body":"Ruby on Rails, for just over 18 months now.  If I were evaluating today, I'd seriously consider Django, too.  I came from a Java background, in an environment where it was actually pretty effective, but the first time I used RoR it just blew my mind.  My subjective experience of coding using Ruby--simply thinking straight into code--is unmatched, thought I haven't spent much time using Python.  It offers probably 95% of what I like about lisp, but requires less syntactical gymnastics to accomplish it.  Two of us reimplemented, in three months, an existing java app (that neither of us wrote the first time) which had taken a team of 5 a year to produce, in 1/5 the LOC.  Even taking into account the greater skill level of the new team, and the fact that we knew exactly what we were building the second time around, that's an impressive result.  The code is inherently well-organized, and easy to refactor.  \r\n\r\nThings I especially like:\r\n\r\n* Capistrano.  Recommended even if you're not doing rails.  We manage deployment across multiple servers easily, quickly and w/o a dedicated release engineer.\r\n\r\n* Action Support.  Set of enhancements to the ruby core to make things more convenient.  10 years ago, as a C programmer, I probably would have recoiled at the sight of this: 14.days.ago.  It's a small thing, I agree, but it nevertheless fills me with delight every time I use it.  And so far, the sky has not fallen.\r\n\r\n* Blocks.  Some elements of their syntax could use improvement, but on balance they give me everything I want from first class functions, but with better integration into an imperative flow.\r\n\r\n* Routing.  Easily make your URLs sensible and organized however you like.\r\n\r\nThings that could be better:\r\n\r\n* Documentation.  Django is giving them a run for their money in this department.\r\n\r\n* A number of irritating gaps and inconsistencies.\r\n\r\n* ActionMailer doesn't seem quite finished, though that may have improved in 1.2\r\n\r\n* ActiveRecord's overhead is HUGE.  For a normal page with less than 100 objects, it's fine.  If you're doing any sort of batch processing, it really really blows.  It really would be nice to do batch processing using ActiveRecord, especially if you're following Rails convention and enforcing your integrity constraints in Ruby code.  And it's not just because Ruby is slow, because when we use Ruby to munge SQL by hand, we get acceptable throughput.  Ordinary site performance has been a non-issue.\r\n\r\n* MySQL.  Not part of Rails, but in some ways mighdt as well be.  I kinda wish we'd gone with PostgreSQL, though not enough to switch at this point.  You end up using replication for EVERYTHING with MySQL.  Live backups.  Scaling beyond 2 procs.   \r\n\r\n* Subversion.  Rails also heavily favors SVN for source control.  Free is nice, as is offline use, but I'm totally spoiled by Perforce when it comes to branching and merging.\r\n\r\nAll in all, though, I remain completely thrilled with the framework and excited to see what comes next.  \r\n","controversiality":0,"subreddit_id":"t5_2fwo","stickied":false,"link_id":"t3_w0ju","subreddit":"programming","score":3,"ups":3,"created_utc":1167156209,"author_flair_css_class":null,"author":"kemiller","author_flair_text":null,"edited":false,"id":"cw2of","parent_id":"t3_w0ju","gilded":0,"distinguished":null,"retrieved_on":1473809418,"timestamp_epoch":1566236778,"message_id":"51433-8b508b51-625a-4253-aeeb-dd36e5462350-1566236778"}
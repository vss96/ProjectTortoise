{"gilded":0,"retrieved_on":1473809515,"distinguished":null,"author":"nostrademons","author_flair_text":null,"edited":false,"parent_id":"t1_cw7dw","id":"cw7ow","subreddit":"programming","author_flair_css_class":null,"created_utc":1167276059,"score":10,"ups":10,"controversiality":0,"body":"I'd thought about this too.  Problem is - what about functions where we actually *want* to manipulate monadic values.  For example, `map` would probably become semantically equivalent to `mapM` under this scheme:\r\n\r\n    map :: (a -&gt; b) -&gt; [a] -&gt; [b]\r\n    mapM :: Monad m =&gt; (a -&gt; m b) -&gt; [a] -&gt; m [b]\r\n\r\nWhat happens to the case where you really *want* to map a Kleisli arrow over a list and end up with a *list of monadic actions* (`[m a]`)?  I've found this to be surprisingly useful - you can store actions in data structures, take only every other one, keep a list of actions that have been executed, and so on.  If every function was a Kleisli arrow and the default evaluation semantics sequenced them together with &gt;&gt;=, then we'd be force to evaluate them as soon as they're passed.\r\n\r\nI guess it's a question of what you're giving up.  This would make Haskell much closer to strictly-evaluated languages with a well-defined evaluation order, like Common Lisp.  You'd lose some of the first-class-ness of monadic actions.  You would definitely lose lazy evaluation - after all, the whole point of allowing silent monad coercions is so you can change a function to perform some I/O or stateful computation, but this requires that you define an evaluation order.  And you don't really save in maintenance unless you define some automatic coercion scheme between different monadic (or arrow) types.  But if you do that, you lose out on much of the type-safety that monads give you.\r\n\r\nI'm definitely interested in this - interested enough that I'm playing around with some toy languages that may very well morph into this.  But there're some very thorny issues involved.  It definitely wouldn't something that could be bolted onto Haskell - at the least, this would be a new language.","link_id":"t3_w79v","stickied":false,"subreddit_id":"t5_2fwo","timestamp_epoch":1566236779,"message_id":"54246-0a6ffd30-43f5-4b2d-8291-4a9272d704bf-1566236779"}
{"author_flair_text":null,"author":"kawa","id":"cv2ku","parent_id":"t1_cv2im","edited":false,"gilded":0,"distinguished":null,"retrieved_on":1473808729,"body":"Ok, if you consider this as 'one page'... And it's far from complete. the interesting stuff is completely missing. On this level there is no difference between Haskell and Ocaml.\r\n\r\nDon't you think that a description of Java on this level wouldn't be a lot smaller? What concepts has Java? Classes. Methods. Statements. Few simple Types. That's it. If we leave out generics and inner classes then a similar tour for Java would be half as long.\r\n\r\nPattern matching is more complicated (and also more powerful) than method-dispatch. And if-then-else is available in Haskell too.\r\n\r\nHaskell is no simply language. If you want a simple, pure functional language, look at the original Miranda for example. Haskell has lots of additions to make the code more concise by letting the compiler do the dirty work. This makes the language less simple - but also more powerful. \r\n\r\nWhile it's possible to make even simple languages extremely complex (look at C++ as a perfect example), powerful languages always require a certain degree of complexity. If build in directly into the language (like in Haskell) or user-defined via macros (like in Common Lisp, but I consider Haskell as much more powerful - but also more complex - than Common Lisp).\r\n\r\nAnd the complexity of the implementation is a part too. Of course it's not a problem for the programmer. But look at it this way: Think about a modern car (with all those nice electronic gadgets like GPS navigation etc., sophisticated electronic engine control and security features, automatic transmission etc.). Then compare this with a old Model-T. Even if the Model-T is much more simple, it isn't as simple and comfortable to use than a modern car. And you can't even expect this. To get simplicity in use you often need high complexity under the hood.\r\n\r\nWith programming languages it's the same: If we want more comfortable and more powerful languages, we need more sophisticated and complex languages and compilers - those can be even more easy to use than the more simply ones, but under the hood they're always much more complex (I wrote about this topic in my blog [here](http://kawagner.blogspot.com/2006/11/rich-languages-vs-minimal-languages.html))\r\n","controversiality":0,"subreddit_id":"t5_2fwo","stickied":false,"link_id":"t3_uzuc","subreddit":"programming","score":5,"ups":5,"created_utc":1166318867,"author_flair_css_class":null,"timestamp_epoch":1566236770,"message_id":"33142-47bc01d9-3ceb-4a9e-ae9a-c564a903bbc1-1566236770"}
{"subreddit":"programming","created_utc":1166287421,"author_flair_css_class":null,"score":11,"ups":11,"body":"The problem is not actually solvable as stated, because JavaCC doesn't generate a parse tree by default, and if it did it would depend on the specific grammar used.  Assuming that we're using the Java 1.5 example grammar that comes with JavaCC, modifying it to return the SimpleNode type that comes with the distribution, and preprocessing with jjTree (also included with the distribution) so that it returns a SimpleNode tree instead of just recognizing text, we get:\r\n\r\n    public Set≺SimpleNode&gt; extractWidgets(SimpleNode node) { return extractWidgets(node, new HashSet≺Node&gt;()); }\r\n    private Set≺SimpleNode&gt; extractWidgets(SimpleNode node, Set≺SimpleNode&gt; acc) {\r\n      for(int i = 0; i ≺ node.jjtGetNumChildren(); ++i) {\r\n        extractWidgets((SimpleNode) node.jjtGetChild(i), acc);\r\n      }\r\n      if(node.getFirstToken().kind == JavaParserConstants.IDENTIFIER &amp;&amp; node.getFirstToken().image.endsWith(\"Widget\")) acc.add(node);\r\n      return acc;\r\n    }\r\n\r\nThat's 8 (long) lines, but two of them are just closing braces, which you would need in the Haskell if you weren't using layout.  So I'd argue that this ought to count.  Now, off to e-mail the blog challenger.\r\n\r\n(It was 7, but I forgot the return statement.  You can get it back to 7 with a little crazy formatting:\r\n\r\n    public Set≺SimpleNode&gt; extractWidgets(SimpleNode node) { Set≺SimpleNode&gt; retVal = new HashSet≺Node&gt;(); extractWidgets(node, retVal); return retVal; }\r\n    private void extractWidgets(SimpleNode node, Set≺SimpleNode&gt; acc) {\r\n      for(int i = 0; i ≺ node.jjtGetNumChildren(); ++i) {\r\n        extractWidgets((SimpleNode) node.jjtGetChild(i), acc);\r\n      }\r\n      if(node.getFirstToken().kind == JavaParserConstants.IDENTIFIER &amp;&amp; node.getFirstToken().image.endsWith(\"Widget\")) acc.add(node);\r\n    }\r\n\r\nBut I think that violates the spirit of the challenge.  If you relax the API a little so that the accumulator is passed in instead of returned, you can get rid of the recursive helper entirely and go down to 6, or 4 without braces.)\r\n\r\nCome to think of it, if I format things like this:\r\n\r\n    public Set≺SimpleNode&gt; extractWidgets(SimpleNode node) { return extractWidgets(node, new HashSet≺Node&gt;()); }\r\n    private Set≺SimpleNode&gt; extractWidgets(SimpleNode node, Set≺SimpleNode&gt; acc) {\r\n      for(int i = 0; i ≺ node.jjtGetNumChildren(); ++i) extractWidgets((SimpleNode) node.jjtGetChild(i), acc);\r\n      if(node.getFirstToken().kind == JavaParserConstants.IDENTIFIER &amp;&amp; node.getFirstToken().image.endsWith(\"Widget\")) acc.add(node);\r\n      return acc;\r\n    }\r\n\r\nI'm at 5 lines + a trailing brace anyway, and these are all coding conventions that you'd see in production Java code.","controversiality":0,"stickied":false,"link_id":"t3_uzuc","subreddit_id":"t5_2fwo","gilded":0,"retrieved_on":1473808703,"distinguished":null,"author":"nostrademons","author_flair_text":null,"edited":false,"id":"cv18g","parent_id":"t3_uzuc","timestamp_epoch":1566236770,"message_id":"32485-18794f86-967c-4005-bec4-48965febaed4-1566236770"}
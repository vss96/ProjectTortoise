{"subreddit":"programming","created_utc":1167525070,"author_flair_css_class":null,"score":10,"ups":10,"controversiality":0,"body":"The basic initial idea to get the hang of working with IO in Haskell is this: take the real work of the program and implement it first without any IO at all. You can test it as you go using GHCi as your user interface of sorts. Basically, this won't involve the IO monad at all -- anything which would need the IO monad can be classified as some type of input or some type of output and made into a parameter or return value. Once you have that done, write the IO which implements the \"user interface\" of the program. The only things which really have to be in the IO monad are things which are actually responsible for handling the IO of the program.\r\n\r\nOf course, there are more complex approaches to structuring programs, those involving concurrency, for instance, or even just programs where the IO is slightly more blended with the pure code where it's convenient, but this is the first one which you need to understand in order to properly manage the rest of them.\r\n\r\nLet's see a tiny example. Suppose we want to write a program which simply goes through the lines of standard input, and determines whether each one is a palindrome. If it is, we'll print it back out, and if not, we won't. (Essentially, we're grepping for palindromes.)\r\n\r\n    isPalindrome :: String -&gt; Bool\r\n    isPalindrome x = x == reverse x\r\n\r\n    grepPals :: String -&gt; String\r\n    grepPals = unlines . filter isPalindrome . lines\r\n\r\nAs you can see, grepPals implements the entire transformation from input to output of our program. In general, we might not be able to get quite this level of separation, but we can usually get pretty close.\r\n\r\nNow as it turns out, there's actually a Prelude function called interact which turns a function from strings to strings into an IO action that eats standard input, and produces standard output. This is almost too ideal, so I'll include a simple definition of interact here, so we can see how it works (in an actual implementation, it also turns off  any buffering which might be present):\r\n\r\n    interact :: (String -&gt; String) -&gt; IO ()\r\n    interact f = do s â‰º- getContents\r\n                    putStr (f s)\r\n\r\nSo it gets the contents of stdin, binding them (lazily, in this case) to the variable s, and then applies whatever function f is given in order to produce output, printing the resulting string.\r\n\r\nThus, our final program is:\r\n    \r\n    main = interact grepPals\r\n\r\nYou can see how the \"real work\" of deciding whether something is a palindrome and filtering the input was done without the IO monad at all. Only the actual IO to be performed was described in the IO monad, in terms of the pure transformations we're applying.\r\n\r\nAs for all the other monads, the question as to whether and where to apply them is a bit more subtle. Each of them captures an idiom from pure functional programming, and abstracts away all of the \"scaffolding\" of that idiom, so they can save time and prevent bugs when used in appropriate places. \r\n\r\nThe Reader monad captures the idea of lexical scoping -- the computation may read from a computation-global environment, and locally make changes to it which go away as soon as the local block finishes. The Maybe and (Either e) monads capture the idea of potential failure, and allow it to be easily propagated out to where it can be handled. The list monad is perfect for selecting between possibilities and backtracking when one possibility fails, giving a type of Prolog-style nondeterministic computation. Parsing monads are for, well, parsing.\r\n\r\nLearning a new monad is a bit like learning a small programming language which sits inside of Haskell and is geared to a specific set of tasks. Eventually, when you get to working with monad transformers, you'll see that there are tools for quickly building up just the monadic language you want to work with to solve your problem.\r\n\r\nThe operations in Control.Monad work with all the monads, with subtly different, but related effects in each. They're essentially a bunch of general control-flow devices which work across monads -- things like for-loops and so on which imperative languages usually handle at the compiler level. This is what saves all the effort of just designing entirely new libraries for these various idioms. You don't need to reimplement things like loops every time.\r\n\r\nHope this helps, come and discuss it on IRC sometime if you'd like. :)\r\n\r\n - Cale","stickied":false,"link_id":"t3_wg2y","subreddit_id":"t5_2fwo","gilded":0,"retrieved_on":1473809708,"distinguished":null,"author":"cgibbard","author_flair_text":null,"edited":false,"parent_id":"t1_cwgrc","id":"cwi32","timestamp_epoch":1566236780,"message_id":"59350-b964605f-5193-4c91-af24-102c610e8cb5-1566236780"}
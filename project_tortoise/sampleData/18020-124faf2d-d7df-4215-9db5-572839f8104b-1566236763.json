{"controversiality":0,"body":"No, it isn't a difficult design decision to justify in the face of the following facts:\r\n\r\n1. Python's syntax is explicitly designed to be very simple.\r\n\r\n2. Python is not trying to be the \"most purely\" OO. It was OO from the start. That's all the article claimed. Not that it is the \"most purely\" OO. There is no question that Python is not the \"most\" OO because it has functions as a first-class construct and builds methods on those rather than vice versa.\r\n\r\nPython is not purely OO or function or imperative at all. The only measure of \"OO\" that interests me is whether OO programmers can efficiently get their jobs done in Python. I've never heard anyone claim otherwise. \r\n\r\nI've not heard one Ruby programmer explain how they had to write hundreds of lines of Python to work around its float syntax or its different handling of metaclasses or its different method sending semantics. Python code is as or more reliable than Ruby/Smalltalk code, more efficient than Ruby at least, typically more readable (by virtue of being syntactically simpler) and Python programmers are basically as productive as Ruby programmers except when they are taking advantage of Python's superior libraries and more mature language implementations. So the argument about OO purity is just so much philosophical wankery.\r\n\r\nBut as long as we're fooling around with sillyness, how about this?\r\n\r\nIn Python, the is_instance function is an instance of object, as it should be:\r\n\r\nprint isinstance(isinstance, object)\r\n\r\nBut Ruby's syntax gets in the way of me even asking the question:\r\n\r\nputs Object.kind_of?.kind_of?(Object)\r\n\r\nWhy won't Ruby allow me to call the kind_of? method on the kind_of? method object?\r\n\r\nPlease don't answer the question as if I don't know the answer. The point is that once you go digging in the dark corners of any real-world language you will find weird bits.\r\n\r\nWhile I'm at it, people always say that Python's closures are broken. But Ruby's are totally borked.\r\n\r\nTry this:\r\n\r\n    def make_printer(value)\r\n       def printer()\r\n           puts value\r\n       end\r\n       return printer\r\n    end\r\n\r\n    printer = make_printer(\"hello\")\r\n    printer()\r\n    printer()\r\n\r\n\r\nThis intuitive code clashes with quirks of Ruby's model in a variety of ways. With a few minor syntax changes this works out of the box in Python and Ruby.\r\n","link_id":"t3_u2mr","stickied":false,"subreddit_id":"t5_2fwo","subreddit":"programming","author_flair_css_class":null,"created_utc":1165646267,"score":4,"ups":4,"author_flair_text":null,"author":"Smallpaul","parent_id":"t1_cu6ym","edited":false,"id":"cu7n3","gilded":0,"retrieved_on":1473808147,"distinguished":null,"timestamp_epoch":1566236763,"message_id":"18020-124faf2d-d7df-4215-9db5-572839f8104b-1566236763"}
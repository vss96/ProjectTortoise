{"author":"cgibbard","author_flair_text":null,"parent_id":"t1_cw1xo","edited":false,"id":"cw2i6","gilded":0,"distinguished":null,"retrieved_on":1473809414,"body":"That's a pretty awkward description. It makes it sound like the constructors somehow transform the data they're given, when that's not the case.\r\n\r\nBasically, what it allows you to do is to give the data constructors associated with a type constructor any types you would like. (Though they must result in a value of the type you're defining.)\r\n\r\nA common example to give is this Term type which illustrates much of the capabilities of GADTs:\r\n\r\n    data Term a where\r\n        Lit    :: Int -&gt; Term Int\r\n        Succ   :: Term Int -&gt; Term Int\r\n        IsZero :: Term Int -&gt; Term Bool\\t\r\n        If     :: Term Bool -&gt; Term a -&gt; Term a -&gt; Term a\r\n        Pair   :: Term a -&gt; Term b -&gt; Term (a,b)\r\n\r\nNote that while IsZero takes a (Term Int) parameter, and gives a (Term Bool), no actual Boolean value is being stored there. Why would you want this? It's a record of the type which the evaluator is going to give you as a result of evaluating the term. It will extract the Int by evaluating the term which IsZero is holding, and then test if it is zero, producing a Boolean value then.\r\n\r\nFor completeness, here's the actual evaluator for this simple language:\r\n\r\n    eval :: Term a -&gt; a\r\n    eval (Lit i)      = i\r\n    eval (Succ t)     = 1 + eval t\r\n    eval (IsZero t)   = eval t == 0\r\n    eval (If b e1 e2) = if eval b then eval e1 else eval e2\r\n    eval (Pair e1 e2) = (eval e1, eval e2)\r\n\r\nIt just has to replace the data constructors of the type with appropriate Haskell code. I like to think of GADTs as giving you the ability to hijack Haskell's typesystem in order to apply it to your own embedded languages. It becomes impossible to write things like\r\n\r\n    If (Lit 5) (Lit 6) (Lit 7)\r\n\r\npassing a non-boolean term to If, or\r\n\r\n    If (IsZero (Lit 12))\r\n       (Pair (Lit 5) (Lit 6))\r\n       (Lit 7)\r\n\r\npassing differently-typed terms to the branches of If, because they are type errors. So you can get lots of structural constraints on what values you can build in your type, and so you don't have to worry about your evaluator getting so many terms it can't deal with, because they never could have been constructed in the first place.","controversiality":0,"subreddit_id":"t5_2fwo","stickied":false,"link_id":"t3_w1oz","subreddit":"programming","score":18,"ups":18,"created_utc":1167152915,"author_flair_css_class":null,"timestamp_epoch":1566236778,"message_id":"51349-553adc59-fd40-4b05-8a49-02c2e162c559-1566236778"}
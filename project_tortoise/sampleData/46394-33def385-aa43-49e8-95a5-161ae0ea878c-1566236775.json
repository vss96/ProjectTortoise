{"stickied":false,"link_id":"t3_vr55","subreddit_id":"t5_2fwo","controversiality":0,"body":"To be fair, I'd argue that the convenient abstractions, extensive libraries, safety, automatic memory management, and clarity of code are the vast majority of what make python more productive than some other languages.\r\n\r\nI don't think that a good type system imposes any productivity hit, especially considering the positive impacts of a good type system.\r\n\r\nbad type system &lt; dynamic typing &lt;= advanced type system\r\n\r\nDynamic typing is the \"types don't help that much, we'll just not be concerned with them unless a problem actually occurs\" approach, which is understandable.\r\nHowever, a decent type system can fix the \"don't help that much\" part while also giving additional information and assurances to the programmer.\r\n\r\nOf course, I'm not going to claim that such a type system exists, though it may. Many certainly come close.. I like Lisp's \"static-when-we-can\" approach, and some neat things can be done with OCaml and Haskell.","created_utc":1166828510,"author_flair_css_class":null,"score":5,"ups":5,"subreddit":"programming","edited":false,"id":"cvso8","parent_id":"t1_cvs6o","author":"doubtingthomas","author_flair_text":null,"retrieved_on":1473809228,"distinguished":null,"gilded":0,"timestamp_epoch":1566236775,"message_id":"46394-33def385-aa43-49e8-95a5-161ae0ea878c-1566236775"}
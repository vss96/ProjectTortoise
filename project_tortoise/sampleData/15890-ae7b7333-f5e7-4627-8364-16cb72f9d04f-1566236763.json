{"author":"rmtew","author_flair_text":null,"id":"cu3ya","parent_id":"t1_cu3ju","edited":false,"gilded":0,"retrieved_on":1473808077,"distinguished":null,"controversiality":0,"body":"&gt; It doesn't work smoothly in the majority of cases unless you're using a framework that's very carefully designed to deal with that scenario.\r\n\r\nThe first thing I do when adding live coding to a new codebase I am writing (outside of CCP) is to use a custom namespacing solution for the framework's code and have the code reloading happen only for that code.  \r\n\r\nThat's a framework in itself to some degree, but hardly very carefully designed or more than a page or two of straightforward code.  With that as a base, most every common code change can be put in place.  The one Stackless specific case which fails is where you have a worker tasklet, however that can be addressed by starting those tasklets with a special method.  Which you would tend to do anyway if you used the uthread module, as we do at CCP.\r\n\r\nWithout you providing examples of actual common cases where this is difficult to do..  well, all I can say is that any common case which I have encountered and haven't fixed, is because I have been too lazy to do so.\r\n\r\n&gt; In Erlang ... More importantly, the whole standard library and OTP style of programming is designed to do live upgrades and downgrades of code to production systems.\r\n\r\nRight, Erlang sounds quite interesting, and if I ever have the time I will have a play around with it.  But reading this, I have to wonder how valuable that is.\r\n\r\nHowever Erlang's native ability to do code updates of production code (and especially the part about the standard library) reminds me of the link the original poster gave, \"You can migrate running tasklets between machines on different architectures!\"  It's an cool sounding extreme which, partly due to the difficulty barrier in writing the required code, and a perhaps limited need to do so, not many  people will be taking advantage of.\r\n\r\nFor one thing, updating the standard library under running production code may be something you need to do in a telecoms environment which presumably can never go down.  But for the general Python user, the standard library will never change.  And I imagine for the general Erlang user.\r\n\r\nThen theres the risk.  Even given a sufficient distinction between state and code, as you give as a benefit of Erlang's functional style, how certain can you ever be that code which changes under the state which a previous version of it used will be 100% guaranteed to be compatible with both that state and how it is used?  What happens if a live update to production code breaks a particular running process?","stickied":false,"link_id":"t3_u2ng","subreddit_id":"t5_2fwo","subreddit":"programming","created_utc":1165585463,"author_flair_css_class":null,"score":1,"ups":1,"timestamp_epoch":1566236763,"message_id":"15890-ae7b7333-f5e7-4627-8364-16cb72f9d04f-1566236763"}
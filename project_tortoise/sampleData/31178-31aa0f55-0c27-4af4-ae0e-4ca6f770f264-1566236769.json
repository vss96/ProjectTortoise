{"stickied":false,"link_id":"t3_uuzg","subreddit_id":"t5_2fwo","body":"I'm only casually familiar with Haskell, but it strikes me that Haskell's syntax is highly optimized for problems like the Fibonacci example. The Haskell code I've seen that deals with typical UI tasks starts to look pretty obtuse.\r\n\r\nI don't mean to pick on Haskell here, because I don't know the language well enough to go either way on it. But I have an intuitive feeling that any time a language's syntax is highly optimized to express a particular kind of problem, it will fall apart somewhat when faced with an unrelated problem.\r\n\r\nA language like Lisp (with which I am also only casually familiar) does not seem to be optimized toward a particular family of problems. On the one hand, the syntax doesn't express any problem particularly well. But the upshot is that you're less likely to find yourself shoehorning a problem into a syntax that was not intended for it.\r\n\r\nAgain, my intent is not to evangelize a particular language here. But I'm not actually sure it's possible to have a language which expresses all problems naturally. In light of that, it would seem that the choice is either to choose a language which expresses your particular problem very well, or one which expresses most problems so-so.\r\n\r\nIn the end, it seems like it will be difficult to find build good library support for a language which is best suited to a narrow family of problems.","controversiality":0,"created_utc":1166210690,"author_flair_css_class":null,"score":3,"ups":3,"subreddit":"programming","edited":false,"id":"cuy5s","parent_id":"t3_uuzg","author_flair_text":null,"author":"crwper","retrieved_on":1473808645,"distinguished":null,"gilded":0,"timestamp_epoch":1566236769,"message_id":"31178-31aa0f55-0c27-4af4-ae0e-4ca6f770f264-1566236769"}
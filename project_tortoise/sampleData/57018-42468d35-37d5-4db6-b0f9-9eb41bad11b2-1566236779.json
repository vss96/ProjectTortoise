{"author_flair_css_class":null,"created_utc":1167412885,"score":1,"ups":1,"subreddit":"programming","link_id":"t3_w79v","stickied":false,"subreddit_id":"t5_2fwo","controversiality":0,"body":"Well, my point got a bit lost in my random ramblings, sorry for that. \r\nI wanted to point out that any Foldable provides fold and foldM, that from fold you define filter, and that from foldM you define filterM. But actually filter cannot be defined generally with the expected type:\r\n\r\n    filter :: Foldable f =&gt; (a -&gt; Bool) -&gt; f a -&gt; f a\r\n    filterM :: Foldable f, Monad m =&gt; (a -&gt; m Bool) -&gt; f a -&gt; m (f a)\r\n\r\nNote that I said generally. Structural or other type of invariants preclude this. Considering the filtering of a balanced tree for example. After identifying the subset of filtered elements, you need to rebuild, or at least rebalance, the tree. \r\n\r\nThe best we can do generally(again) is to define a pseudo-filter:\r\n    \r\n    filter :: Foldable f =&gt; (a -&gt; Bool) -&gt; f a -&gt; [a]\r\n    filterM :: Foldable f, Monad m =&gt; (a -&gt; m Bool) -&gt; f a -&gt; m [a]\r\n\r\nAnd then create specific instances of filter using the appropiate constructors:\r\n\r\n    filterSet pred = Set.fromList . filter pred\r\n    filterSetM pred = liftM Set.fromList . filterM pred\r\n\r\n\r\nThis solves it for filter. But of course, you are right in that not any function can be trivially lifted to a monad: as you point out, higher order functions cannot. The problem is that Higher Order functions generally turn into control structures when monadified, and evidently the programmer must specify them.\r\n\r\nConsider filterM: which are the monadic semantics of filterM ? Is it a right or left folding of the structure? Is it even defined as a fold? This doesn't matter (semantically at least) for the pure version, but does, a lot, for the monadic version.\r\n\r\n    filterM pred list = do\r\n      bools &lt;- mapM pred list\r\n      return [ elem | (True,elem) &lt;- zip bools list]\r\n\r\nThis definition applies the predicate to all elements first using a right fold (implicitly defined in map), and then takes the filtered subset. But why should it be done this way? A better option might be to cache the applications of the predicate as we go, in case we encounter duplicate elements in the list. \r\n\r\nBut wait, every time we apply the predicate there are possible side-effects involved, or not? It depends on your monad! That's why Haskell needs you to specify these things.\r\n\r\nEven if you have to define your own filterSetM, it is not that annoying. But you got a point, it cannot be totally automated. Nevertheless, as a newb (1 year) Haskell programmer, I must say that I cannot remember having found this to be a problem *per se*. Monadic refactorization *is* an annoying task, and I wish that the tools for doing it automatically were available.\r\n\r\n","retrieved_on":1473809621,"distinguished":null,"gilded":0,"edited":false,"id":"cwdev","parent_id":"t1_cwclm","author_flair_text":null,"author":"pepegg","timestamp_epoch":1566236779,"message_id":"57018-42468d35-37d5-4db6-b0f9-9eb41bad11b2-1566236779"}
{"retrieved_on":1473808587,"distinguished":null,"gilded":0,"edited":false,"id":"cuv46","parent_id":"t3_uuzg","author_flair_text":null,"author":"[deleted]","author_flair_css_class":null,"created_utc":1166160960,"score":-5,"ups":-5,"subreddit":"programming","link_id":"t3_uuzg","stickied":false,"subreddit_id":"t5_2fwo","body":"Interesting. I want to respond to this because I missed out on yesterday's conversation even though I thought about this as I drove out in the morning. \r\n Syntax and simplicity is sometimes over rated. When we establish a language as having \"the simplest possible syntax\", or maybe the \"prettiest syntax\", we're using a predicate that's quite vague.\r\n\r\n You could intrepret it as the language with the least amount of commands and characters (that one that goes +++++_._++++++...), or you could interpret it to mean the least amount of lines of code. Or some other (probably unobjective) predicate.\r\n\r\n The problem is that the real world isn't simple. Take type inference for example. It's great sometimes, but other times it isn't. I can say this without any hint of a doubt in mind. Why? Because Mathematics does *not* have type inference. Mathematics is *all* about defining type. \"For any x in N\", \"for any y in Z\"... Really, even in set theory which is the end all be all in vagueness, you never go about saying \"for any x\" without defining it with some sort of predicate. In fact, in mathematics, \"for any x\" doesn't really mean anything.\r\n\r\n The other thing is that simplifying programming languages to become \"spoken-like\" is not necessarily a great idea. Human languages are notoriously polysemantic in nature. People write entire neural networks, with probability trees and complex graph traversals to get machines to understand what a human says. But even the masters of that - humans themselves - often go to war over misunderstandings. So that isn't an awesome thing either.\r\n\r\n So is it maybe the elegance with which you can write the solution for your problem? Say the fibonnacci sequence? Well, again I will come back to mathematics, I could write the solution to any problem in the world like so: \"Let x be the solution for any solvable problem y\". There you go, I've solved it. Everything.\r\n\r\n That sounds ridiculous, but I guarantee you it's not. Real world example: factorial. In math it's defined iteratively. We all know it. But there's also an explicit function to factorial which is quite ugly: an integral from 0 to inf. You feed it a number, it spits you an answer: without going through the itterative process.\r\n\r\n Peoples' complaints about real world examples and fibonnacci numbers not being the same are because of this. The problem is that a computer program that's just too distilled is like rubbing alcohol. It's just not pottable anymore. Somewhere, as a real world programmer, we need to be able to break down the task at hand into reasonable steps (\"and then, do this. If that fails, do that\"). We can't be expected to write out expressional masterpieces which will be both tight and correct.\r\n\r\n An analogy to be made is english language. Sure, some people like Shakespeare used english to write masterpieces, but imagine what would happen to society if at the starbucks you asked for a coffee and the clerk refused to serve you unless you spoke in Alexandrine Sonnet.\r\n\r\n I could rate my language by it's expressiveness. C++ for example, has astounding expressiveness. Lisp even more than C++. VB doesn't.\r\n I would use VB over any language to access COM objects - it was designed for it. For algorithmic work, Lisp can't be beat. For writing a game engine? Sure you could write an entire monster in Doom to be one big lambda function FSM with continuations in LISP. But really, who wants to debug that, when you can step by step see what the computer is doing in a language like C++.\r\n\r\nEdit: this post moderated courtesy of the Thought Police","controversiality":1,"timestamp_epoch":1566236769,"message_id":"29825-275b2623-8fd1-40cf-bcf1-32f5d85f8d2b-1566236769"}
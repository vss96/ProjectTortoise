{"subreddit":"programming","author_flair_css_class":null,"created_utc":1167317630,"score":4,"ups":4,"body":"I know that I'm far from a Haskell expert so I expect that there are better solutions to almost any problem I encountered.\r\n\r\nBut to find this solutions you have to build knowledge about the language - which you can only get if you have time to do some real work in the language. Experiments with toy-code are not enough, it gets totally different if you start to encounter a problem which has to be solved in the existing framework of the code you wrote. Where your changes requires rewriting lots of code you've tested and which you want to maintain. If Haskell should really be an alternative to languages like Java, Python or even Ocaml the learning curve has to be considered.\r\n\r\nI know how to solve most problems in pure functional way, but sometimes I simply don't know if mutation will be necessary in a particular part of the code before I start implementing it. And I'm not even one of those fans of 'agile-methods' who even consider thinking about static types a burden.\r\n\r\nMutation isn't even necessarily 'unfunctional', you can almost always use the \"new_state = modify old_state\" pattern but to do this you have to bring the state in and out of your code somehow.\r\n\r\nBut I don't think that MVars, IORefs or unsafeIO a valid solution to this. Those are hacks, if they are necessary if you write code on a bigger scale without running into refactoring issues all the time, I consider the concept of Haskell a failure.\r\n\r\n","controversiality":0,"link_id":"t3_w79v","stickied":false,"subreddit_id":"t5_2fwo","gilded":0,"retrieved_on":1473809541,"distinguished":null,"author_flair_text":null,"author":"kawa","edited":false,"parent_id":"t1_cw7hz","id":"cw94w","timestamp_epoch":1566236779,"message_id":"54920-03528b92-ab46-463d-93cc-d96ecb3d32e4-1566236779"}
{"ups":1,"score":1,"author_flair_css_class":null,"created_utc":1167515016,"subreddit":"programming","subreddit_id":"t5_2fwo","link_id":"t3_wg2y","stickied":false,"controversiality":0,"body":"In Imperative Language X, you are handed the file system and the network as implicit function arguments - watch this:\r\nint sum(int a, int b) {\r\n  if(someFileExists()) {\r\n    return 42;\r\n  } else {\r\n    return a + b;\r\n  }\r\n}\r\nIn Haskell, this is not the case - instead these things are passed explicitly - within the IO monad. This statement is a little lossy, but please forgive that for now. The reason that you likely had to continually use the IO monad was:\r\na) Your application was using one of these arguments within its foundations - every other function was built on top of the state of the file system or network\r\nb) You're used to having the file system and network within your context and struggled to differentiate where it is required\r\n\r\nGood idea for remaining agnostic on the issue until you can clue up and understand a bit better.","distinguished":null,"retrieved_on":1473809699,"gilded":0,"edited":false,"parent_id":"t1_cwgrc","id":"cwhl5","author":"[deleted]","author_flair_text":null,"timestamp_epoch":1566236780,"message_id":"59094-926f80ce-a9ac-420e-8a40-c729a1b2ea7e-1566236780"}
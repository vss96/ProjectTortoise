{"subreddit":"programming","score":1,"ups":1,"author_flair_css_class":null,"created_utc":1165336897,"body":"The points (as argued): reduced interrupt traffic and task switching on the fast CPU, reducing cache pollution in the fast CPUs and maximizing the potential of CPU features that actually make the CPU fast, and having another CPU to do stuff (extra parallelism relatively cheaply, and fast enough for lots of things - simple UltraSPARC II-derived cores in the UltraSPARC T1 chips as evidence).  There has been plenty of people who think these reasons are not very good, and I take it you're one of them. :)\r\n\r\nOther points (not argued in the article): the slower CPU is good enough for lots of other tasks, not just kernel code.  As you said, CPUs often idle waiting for interrupts.  I'll continue with the US II vs. US IV example here.  Lots of code is predominantly integer, and the slow CPU is good enough to run web servers (particular static file delivery), your command shell, and stuff like that.  Going further, there could be a way for the kernel to recover from running a program not suited for the slow CPU and moving it to a fast CPU.  Let's say it mistakenly runs a thread that needs fancy instructions on the slow CPU.  The instruction decode stage of the pipeline just needs to be enhanced to distinguish between \"illegal instruction\" and \"unsupported instruction,\" throwing slightly different traps.  The unsupported instruction trap can stop the thread, save its state, and can add a little bit of extra info to that thread structure in the kernel so it won't run it on that CPU again.  In steady-state, the system can use all CPUs at maximum potential performance, the slow CPUs included.\r\n\r\nAlso, I'd like to know why you think the slow CPU \"surely doesn't want to run [interrupt handlers]\".  Last I checked, that's part of the point.  Also, in my previous post, I mentioned that the fast CPUs could also enter the kernel, which basically suggests that they can perform thread scheduling as well.  Remember, this is fairly close to a traditional SMP design as far as the kernel is concerned, but the CPUs just have vastly different performance characteristics.  So your argument about running scheduling on just one core (which I agree is not a good idea!) doesn't apply.\r\n\r\nTo answer your final question as to how it improves the status quo w/r/t several factors...\r\nThroughput - it's an extra CPU.  You can theoretically gain whatever the maximum throughput of the slower CPU is.  There is quite possibly a more optimal way to design this CPU (somewhere between the very stripped-down design I laid out and a full blown high speed core like the others).  Finding this optimum point, if it exists, is fairly involved.\r\n\r\nResponsiveness - it's an extra CPU.  We can go with one of two approaches - 1. slow CPU is the only CPU that handles interrupts, which is pretty much what I said.  You've provided good evidence why this may not be a good idea.  2. the slow CPU typically lives at a interrupt request level lower than the other CPUs, so that it's the first to be interrupted.  That would improve things would it not (whether or not you think the idea overall is a good one)?  So while you're watching an MPEG4 video and your system is busy doing I/O to get the data from disk or the network, along with other activity - the CPU doing the decoding can maintain a more constant throughput because it's not being interrupted.  This can visibly improve system responsiveness and user experience (no skipping or slowdown etc).\r\n\r\nScalability: it's an extra CPU.  The concept is odd because it involves scaling down towards simple tasks rather than scaling up or specializing for complex tasks.  Nevertheless, I think modern Unix operating systems can leverage this because the slower CPU is still ISA compatible and not a DSP that needs a separate device driver.\r\n\r\nFinally, if it's not obvious by now, I am the author of the article.  I appreciate you taking the time to argue with me about this. :)","controversiality":0,"subreddit_id":"t5_2fwo","link_id":"t3_tj0f","stickied":false,"gilded":0,"distinguished":null,"retrieved_on":1473807811,"author":"zetta","author_flair_text":null,"id":"ctpnu","edited":false,"parent_id":"t1_ctno0","timestamp_epoch":1566236761,"message_id":"9209-4eb55745-1597-4883-8f28-f1238186206f-1566236761"}
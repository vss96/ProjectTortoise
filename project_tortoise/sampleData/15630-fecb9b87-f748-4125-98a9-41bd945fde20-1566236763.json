{"distinguished":null,"retrieved_on":1473808065,"gilded":0,"parent_id":"t1_ck72m","id":"cu3af","edited":false,"author_flair_text":null,"author":"vintermann","score":2,"ups":2,"author_flair_css_class":null,"created_utc":1165568023,"subreddit":"programming","subreddit_id":"t5_2fwo","link_id":"t3_k57e","stickied":false,"controversiality":0,"body":"This one deserved to get downmodded (I'm finding it by the link on your site, where you complain that it was undeserved). Fomal methods is _not_ simply the same as proof of total correctness. Partial correctness, that the program behaves correctly if it does terminate, is often just as valuable. \r\n\r\nThanks to advances in \"heavyweight\" formal methods, very real-world companies like Praxis can make multithreaded real-time control software which are proven to be correct. It's not many years since it was though that proof for multithreaded programs was a lost cause.\r\n\r\nBut lightweight formal methods are even more exciting: with something they call \"symbolic compilation\" and automatic formal reasoning about the result, Coverity has made a powerful programmable static analysis tool, which they sell to companies like Cisco, Raytheon, ARM and Texas Instruments. They applied it to open source software too, and automatically discovered critical errors in OpenSSH, and 1224 errors in KDE. (The KDE team has now fixed all of them).\r\n\r\nDaniel Jackson's Alloy allows you to debug your actual design formalisations, rather than just the implementation, so it can catch a nasty class of errors that unit testing don't handle: those where the program does what you want it to, but where what you want _won't work_.\r\n\r\nJean Raymond Abrial's B language has three competing implementations. It's a specification language which allows stepwise refinement in a formal manner, so the final refinement becomes to executable code which is guaranteed to conform to the original specification. Most famously used for the braking system of the Paris Metro, but one of the implementors is Steria, so it's likely that your bank transaction software is designed in this way, too.\r\n\r\nBut what's your answer? Unit tests? We don't need all this awesome technology, because we've got unit tests? I don't know about the others you linked to, but I think this post deserved MORE downmods than you got.","timestamp_epoch":1566236763,"message_id":"15630-fecb9b87-f748-4125-98a9-41bd945fde20-1566236763"}
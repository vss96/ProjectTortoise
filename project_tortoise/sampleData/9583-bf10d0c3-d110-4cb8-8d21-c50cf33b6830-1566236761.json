{"score":2,"ups":2,"created_utc":1165345564,"author_flair_css_class":null,"subreddit":"programming","subreddit_id":"t5_2fwo","stickied":false,"link_id":"t3_tksn","body":"I'm not sure that I would say Ruby, Perl, and Python \"fit well\" in a unix-like environment. For example: does the system debugger understand their internal data layout? Why do they use byte-code interpreters instead of compiling to native machine code? \r\n\r\nWhat *is* different about these languages is that they historically *followed* Unix, and were generally implemented on Unix, and therefore, their standard libraries, etc., all align pretty well with Unix. \r\n\r\nLisp was originally developed on the IBM 704, and matured on PDP-10s and Lisp Machines. Many of its qualities developed before UNIX was a gleam in Dennis Ritchie's eye, much less a widespread computing platform.\r\n\r\nCompare this to a language no one seems to have mentioned so far: Fortran. Fortran fits well with UNIX because it assumes not much more than a flat memory model and the ability to make subroutine calls. g77 compiles to .o files that gcc can link. Hell, g77 is simply a version of gcc. I can use makefiles to manage my Fortran development. I can use gdb to inspect my Fortran arrays, as long as I remember the different indexing order convention.  No one asks \"how do I make my Fortran program into an executable\" because it is pretty much the same way you make a C executable.","controversiality":0,"distinguished":null,"retrieved_on":1473807825,"gilded":0,"edited":false,"id":"ctqf4","parent_id":"t1_ctlxh","author":"sickofthisshit","author_flair_text":null,"timestamp_epoch":1566236761,"message_id":"9583-bf10d0c3-d110-4cb8-8d21-c50cf33b6830-1566236761"}
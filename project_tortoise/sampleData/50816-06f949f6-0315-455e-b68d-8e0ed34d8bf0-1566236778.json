{"subreddit_id":"t5_2fwo","link_id":"t3_vzw8","stickied":false,"body":"Haskell.\r\n\r\nI haven't found many other languages which give so much ability to express the abstractions you want and, importantly, enforce their correct use.\r\n\r\nStatic typing saves lots and lots of time that would otherwise be spent debugging (you still debug, but the typesystem catches at compile/load time a very large portion of the bugs which you end up looking for at runtime in dynamically-typed, or for that matter, most other statically typed languages. I find it quite frustrating living without that, because time spent debugging is usually not all that fun in any language. Types, when used correctly, also provide really good guide-posts to help you to understand code that you didn't write yourself. They're like differently shaped nubs on building blocks that help you decide how things should fit together. When you come upon new code, you basically have to put the puzzle of how it fits together yourself, from the documentation, and ultimately, the code itself. Having those machine-checked clues there really helps in this process. It helps to guide you to the right place to make your changes, and helps let you know if you've chosen the wrong place.\r\n\r\nAlso on the decreasing-need-for-debugging front, the referential transparency of Haskell tends to be incredibly useful for thinking about your code, reasoning about what it's doing. Mutation and side-effects are very annoying burdens on one's mind when trying to understand code. Being able to confine them precisely, and know exactly where they might be issues worth considering is a huge win in terms of productivity, especially when dealing with code you didn't write yourself.\r\n\r\nLazy evaluation is great, and basically agrees with how I think anyway. I might be strange in that regard, but I personally found it way more natural than strict evaluation ever was (and I'd used 10 or so strict imperative and functional languages over the course of about 10 years before coming to Haskell). It's just how I'd evaluate code myself if I was doing it by hand. Regardless of whether one finds it natural at first, it's certainly quite useful. I seem to find myself writing lots of search algorithms, and lazy evaluation is exactly what you want for that. It also makes it possible to glue together programs that you've written in ways that you wouldn't have even been able to consider before, to do things with plain code that would otherwise involve compile-time macros, and in general, really helps one extract the benefits of functional programming.\r\n\r\nIt's also fairly practical. There are a fairly good selection of libraries available for most tasks now. Not a ridiculously large number, but generally enough that I don't feel really deprived of anything. Performance is decent enough for me that I basically never rewrite sections in C, though it's nice to know that I could if I wanted to.\r\n\r\nAlso, this is very subjective, but the syntax is in my opinion, very clean, letting you express what you mean succinctly without sacrificing readability, and usually has the right abstractions to let you ignore distinctions that you'd rather not make.\r\n\r\nFor one example that I think quite a few people share, I don't think I *really* properly understood quicksort until I read the Haskell code for it. Why and how it worked suddenly became completely obvious to me, and even made the in-place version in C become much simpler to comprehend. These small epiphanies have continued, and happen regularly.\r\n\r\nLast, but certainly not least, the community is wonderful. There are lots of very friendly people in the IRC channel and on the mailing lists. Beginners generally get lots of attention and are basically never told to RTFM, and regardless of your level of expertise, there are a lot of generally pretty bright people with whom to discuss ideas. \r\n\r\nYou have lots of people who are interested in the design and development of programming languages and programming abstractions, and who can generally point you at interesting ideas from many different places.\r\n\r\nHaskell is basically where a fairly sizeable chunk of the programming language research is being tried out, but is managing to be a practical language for everyday sorts of programming, which is a really cool place to be in the spectrum of languages.","controversiality":0,"score":13,"ups":13,"author_flair_css_class":null,"created_utc":1167116710,"subreddit":"programming","id":"cw1ed","parent_id":"t3_vzw8","edited":false,"author":"cgibbard","author_flair_text":null,"distinguished":null,"retrieved_on":1473809394,"gilded":0,"timestamp_epoch":1566236778,"message_id":"50816-06f949f6-0315-455e-b68d-8e0ed34d8bf0-1566236778"}
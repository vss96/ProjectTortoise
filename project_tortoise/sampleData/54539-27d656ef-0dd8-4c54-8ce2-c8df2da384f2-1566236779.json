{"gilded":0,"retrieved_on":1473809525,"distinguished":null,"author_flair_text":null,"author":"cgibbard","id":"cw88s","edited":false,"parent_id":"t1_cw7ow","subreddit":"programming","author_flair_css_class":null,"created_utc":1167291565,"score":5,"ups":5,"controversiality":0,"body":"My opinion on the matter is that for most monads, it just doesn't make a whole lot of sense to mix levels like that. \r\n\r\nThere are a few monads, specifically commutative monads, in which notation that made order of computation less explicit would be appropriate. (Commutative monads are those where for all x, y, f we have do {v ≺- x; w ≺- y; f v w} = do {w ≺- y; v ≺- x; f v w}, for example, the Reader monad.) Even then, I'm not sure I'd want to overload function syntax directly though. You'd still end up with what was an apparent loss of referential transparency. Referential transparency is one of those things which really helps in reading and properly comprehending code, and I think its impact is often underestimated.\r\n\r\nIn the commutative case, it would perhaps work to have some special bracketing notation to show that specific parameters are to be monadically evaluated rather than passed directly.\r\n\r\nIn noncommutative monads (for example, most of them), my feeling is that order matters too much to allow for that sort of thing. Although you can define an order by fiat, it makes implicit information which is important to the reader, which is a sign of bad notation.\r\n\r\nIf monadic code (even in the commutative case) was to look identical to pure code, then it would be far less obvious where referential transparency applied, making your brain have to work harder to read unfamiliar programs, since you'd have to suspect the loss of referential transparency even where it was guaranteed, or worse, you wouldn't suspect it, only to later discover some implicit parameters sneaking by and ruining your understanding of the code so far.\r\n\r\nIf you'd like to experiment with reflecting the Reader monad so as to make its use entirely transparent, check out the implicit parameter extension to GHC.\r\n\r\nBy the way, by severely abusing linear implicit parameters, an uncommonly used extension to GHC which is far more evil than ordinary implicit parameters, it's possible to [reflect arbitrary monads in Haskell code](http://www.haskell.org/tmrwiki/FunWithLinearImplicitParameters), and try this sort of thing out, and see just how bewildering it can be.","link_id":"t3_w79v","stickied":false,"subreddit_id":"t5_2fwo","timestamp_epoch":1566236779,"message_id":"54539-27d656ef-0dd8-4c54-8ce2-c8df2da384f2-1566236779"}
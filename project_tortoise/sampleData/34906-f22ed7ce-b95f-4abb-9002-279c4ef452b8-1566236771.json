{"subreddit":"programming","created_utc":1166406662,"author_flair_css_class":null,"ups":1,"score":1,"controversiality":0,"body":"&gt; No, this is just what i was talking about: 2^32 is only a vanishingly small 0.000000023 percent (less than one billionth) of the keyspace. To cover half of it, you need 2^63 attempts.\r\n\r\nCorrect. Brainfart on my part.\r\n\r\n&gt; You went from a 4-fold increase to a 16-fold increase here. In reality, the checking factor remains constant, and (practically speaking) independent of the key length.\r\n\r\nI understand the checking factor is constant; my point is that you have to apply it to each candidate, increasing the total amount of work done. Consider:\r\n\r\nNumber of attempts needed on average = A\r\n\r\nDecryption time per attempt = t1\r\n\r\nValidation time per attempt = t2\r\n\r\nThe theoretical cryptographer considers only `t1*A`. The practical one considers `(t1+t2)*A`. As you say, t2 is constant and independent of key length; however, it still needs to be considered in the computation time required _per each decryption attempt_.\r\n\r\nMy belief is that `(t1+t2)` can be considerably larger than t1 alone.","stickied":false,"link_id":"t3_uz8g","subreddit_id":"t5_2fwo","gilded":0,"retrieved_on":1473808791,"distinguished":null,"author_flair_text":null,"author":"buo","edited":false,"id":"cv5wc","parent_id":"t1_cv4wz","timestamp_epoch":1566236771,"message_id":"34906-f22ed7ce-b95f-4abb-9002-279c4ef452b8-1566236771"}
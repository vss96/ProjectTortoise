{"distinguished":null,"retrieved_on":1473809347,"gilded":0,"edited":false,"id":"cvywn","parent_id":"t3_vywm","author_flair_text":null,"author":"ayrnieu","score":0,"ups":0,"created_utc":1167031651,"author_flair_css_class":null,"subreddit":"programming","subreddit_id":"t5_2fwo","stickied":false,"link_id":"t3_vywm","controversiality":1,"body":"Non-reentrant banking in various languages.  Please contribute your own.\r\n\r\nAll the following implementations have a hacky, against-the-grain feel to them -- but this C feels perfectly natural!\r\n\r\n    int bank_account (int action, int delta) {\r\n      static int balance = 0;\r\n      switch (action) {\r\n        case BAL_SET:      return balance = delta;\r\n        case BAL_DEPOSIT:  return balance += delta;\r\n        case BAL_WITHDRAW: return balance -= delta;\r\n        case BAL_CHECK:    return balance;\r\n      }\r\n    }\r\n\r\nMore idiomatic Perl would just use a package variable.\r\n\r\n    package BankAccount;\r\n    { my $balance = 0;\r\n      sub set      { $balance = shift }\r\n      sub deposit  { $balance += shift }\r\n      sub withdraw { $balance -= shift }\r\n      sub check    { $balance }\r\n    }\r\n\r\nThe second version *seems* safe, but...\r\n\r\n    variable balance\r\n    : set      ( n -- ) balance ! ;\r\n    : deposit  ( n -- ) balance +! ;\r\n    : withdraw ( n -- ) negate deposit ;\r\n    : check    ( -- n ) balance @ ;\r\n\r\n    \\ bizarre and evil, but hides the variable:\r\n    BASE @ here 1 cells allot BASE !\r\n      : set      ( n -- ) [ base @ ] literal ! ;\r\n      : deposit  ( n -- ) [ base @ ] literal +! ;\r\n      : withdraw ( n -- ) negate deposit ;\r\n      : check    ( -- n ) [ base @ ] literal @ ;\r\n    BASE !\r\n\r\nalas, Forth's architectural openness allows an adversary to immediately gain a critical advantage in inducing reentrancy:\r\n\r\n    see check                    \\ input\r\n    : check\r\n         0x2C6734F0 @ ; \r\n    ok \r\n    0x2c6734f0 constant balance  \\ input\r\n    bob's-balance @ balance !    \\ input\r\n\r\nErlang makes non-reentrancy difficult; the best way seems to to require a gen_server-like process, as follows.  Naive solutions that use an ets table or that expect the caller to keep a single pid around or that even store the balance in the caller's process dictionary?  All fail.\r\n\r\n    -module(bank_account).\r\n    -export([set/1, deposit/1, withdraw/1, check/0]).\r\n    \r\n    start() -&gt;\r\n        case whereis(bank_account) of \r\n            undefined -&gt;\r\n                register(bank_account, spawn(fun init/0)),\r\n                start();\r\n            Pid -&gt; Pid\r\n        end.\r\n    \r\n    init() -&gt; loop(0).\r\n    \r\n    loop(Bal) -&gt;\r\n        receive\r\n            {set, NewBal} -&gt; loop(NewBal);\r\n            {deposit, Delta} -&gt; loop(Bal + Delta);\r\n            {withdraw, Delta} -&gt; loop(Bal - Delta);\r\n            {check, Pid} -&gt; Pid ! {self(), Bal}, loop(Bal)\r\n        end.\r\n    \r\n    set(N) -&gt; start() ! {set, N}.\r\n    deposit(N) -&gt; start() ! {deposit, N}.\r\n    withdraw(N) -&gt; start() ! {withdraw, N}.\r\n    check() -&gt;\r\n        P = start(),\r\n        P ! {check, self()},\r\n        receive\r\n            {P, Bal} -&gt; Bal\r\n        after 10000 -&gt; throw('timed out')\r\n        end.\r\n\r\n\r\nI like this straightfoward O'Caml implementation -- but hiding the balance means doubling the length of the code and repeating a lot of type information.\r\n\r\n    module type BANKACCOUNT =\r\n      sig\r\n        type secretive (* only here to hide the balance *)\r\n        val balance : secretive\r\n        val set : int -&gt; unit\r\n        val deposit : int -&gt; unit\r\n        val withdraw : int -&gt; unit\r\n        val check : unit -&gt; int\r\n      end;;\r\n    module BankAccount : BANKACCOUNT =\r\n      struct\r\n        type secretive = int ref\r\n        let balance = ref 0\r\n        let set n = balance := n\r\n        let deposit n = balance := !balance + n\r\n        let withdraw n = balance := !balance - n\r\n        let check () = !balance;\r\n      end;;\r\n\r\n\r\nEmacs Lisp can't do this without outside help.  No packages, no lexical binding. The code provided below *seems* non-reentrant, but it is yet vulnerable:\r\n\r\n    (let (*bank-balance* *bob*)\r\n      (bank-deposit (let (*bank-balance* *amy*)\r\n                      (bank-withdraw n))))\r\n\r\nYou could even trivially wrap the below in a function that accepts a specific bank account to use for every operation: what a terrible language this is!\r\n\r\n    (defvar *bank-balance* 0)\r\n    (defun bank-set      (n) (setf balance n))\r\n    (defun bank-deposit  (n) (incf balance n))\r\n    (defun bank-withdraw (n) (decf balance n))\r\n    (defun bank-check    ()  balance))\r\n\r\nScheme near-invented lexical binding, so why is this so ridiculous?  Lisp doesn't have a problem with `(let ... (defun ...))`\r\n\r\n    (define temporary\r\n      (let ((balance 0))\r\n        (list (lambda (n) (set! balance n))\r\n              (lambda (n) (set! balance (+ balance n)))\r\n              (lambda (n) (set! balance (- balance n)))\r\n              (lambda () balance))))\r\n    (define bank-set (list-ref temporary 0))\r\n    (define bank-deposit (list-ref temporary 1))\r\n    (define bank-withdraw (list-ref temporary 2))\r\n    (define bank-check (list-ref temporary 3))\r\n","timestamp_epoch":1566236777,"message_id":"49548-c1caba71-e210-45b0-b309-3e81beeed443-1566236777"}
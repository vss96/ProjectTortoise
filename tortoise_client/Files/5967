{"parent_id":"t1_cvebe","id":"cvh6p","edited":false,"author":"[deleted]","author_flair_text":null,"distinguished":null,"retrieved_on":1473809007,"gilded":0,"subreddit_id":"t5_2fwo","stickied":false,"link_id":"t3_vdxw","controversiality":0,"body":"Scheme uses strict evaluation by default and lazy evaluation as a special case.\r\n\r\nHaskell uses lazy evaluation by default and strict evaluation as a special case.\r\n\r\nI personally think it works somewhat nicer in haskell. In haskell you merely need to signal when you want to perform strict evaluation while in scheme you must signal when you want to start lazy evaluation (with a delay) and then resume strict evaluation (with a force) making it slightly more verbose. \r\n\r\nI also think lazy evaluation is a more practical default - it chooses laziness for expressiveness as the default and \r\nstrictness for optimisation as a special case when needed.\r\n\r\nAlso, the fact that haskell is a pure language helps. As you point out, lazy evaluation doesn't work nicely in the presence of side effects. Haskell's \"quarantining\" of side effects makes them work alongside a default lazy evaluation strategy quite nicely.","score":5,"ups":5,"created_utc":1166612376,"author_flair_css_class":null,"subreddit":"programming","timestamp_epoch":1566236773,"message_id":"40592-9f8ffafd-e1dc-4eda-be63-7655729792cb-1566236773"}
{"subreddit_id":"t5_2fwo","link_id":"t3_ujj3","stickied":false,"body":"While I completely agree that these features can be implemented in scheme, it seems that their use by the actual scheme community is limited.\r\n\r\nPattern matching, while supported by various libraries, is not the usual way to define functions. Laziness is usually handled explicitly, which means that it will only be used when it seems to be completely necessary, and this defeats the purpose of laziness overall, which is to make programs more composable. You lose that composability the instant you need to apply some strict library function to the data. (Or you end up rewriting it lazily.)\r\n\r\nNone of this is intended to degrade SICP at all though -- it's a wonderful book, (and a wonderful series of lectures). Many of the lessons learned there are put to work in the syntax of Miranda and Haskell.\r\n\r\nWriting a metacircular evaluator is actually an important part of SICP, and I agree that it would be significantly harder to write a Haskell interpreter in Haskell than a Scheme interpreter in Scheme. However, implementing interpreters for many embedded languages is not difficult, and the importance of having a metacircular evaluator is greatly reduced by having lazy evaluation by default, as things which would have to be implemented as special forms no longer need to be. (Wadler discusses the implementation of interpreters later on in the paper)\r\n\r\nI must admit that there is a certain beauty and elegance in implementing the language which you're using in itself though.","controversiality":0,"score":8,"ups":8,"author_flair_css_class":null,"created_utc":1165941631,"subreddit":"programming","parent_id":"t1_cujum","id":"cul4z","edited":false,"author_flair_text":null,"author":"cgibbard","distinguished":null,"retrieved_on":1473808401,"gilded":0,"timestamp_epoch":1566236767,"message_id":"25056-c86f2dca-7e4f-4dbe-8dc9-f8ae3056c141-1566236767"}
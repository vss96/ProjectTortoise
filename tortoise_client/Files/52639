{"edited":false,"id":"cu8p5","parent_id":"t1_cu7n3","author":"shit","author_flair_text":null,"retrieved_on":1473808168,"distinguished":null,"gilded":0,"link_id":"t3_u2mr","stickied":false,"subreddit_id":"t5_2fwo","body":"&gt; But Ruby's syntax gets in the way of me even asking the question:\r\n\r\n&gt; `puts Object.kind_of?.kind_of?(Object)`\r\n\r\nWhat a bullshit. Ruby has a message passing object system. And it does exactly what you told it to do. And you get what you deserve. In Python there is no message passing. Only attribute lookup (instance &amp; class conflated in the same syntax) + function call.\r\n\r\n&gt; While I'm at it, people always say that Python's closures are broken. But Ruby's are totally borked.\r\n\r\n... broken code\r\n\r\n&gt; This intuitive code clashes with quirks of Ruby's model in a variety of ways. With a few minor syntax changes this works out of the box in Python and Ruby.\r\n\r\nBullshit. In Ruby code this is:\r\n\r\n    def make_printer(value)\r\n        lambda { puts value }\r\n    end\r\n    printer = make_printer(\"hello\")\r\n    printer.call()\r\n    printer.call()\r\n\r\n`def` defines methods, not closures. You better learn Ruby before you try to criticize it.","controversiality":0,"author_flair_css_class":null,"created_utc":1165679922,"ups":1,"score":1,"subreddit":"programming","timestamp_epoch":1566236764,"message_id":"18504-890f80b1-a936-4bef-a43e-138938466179-1566236764"}
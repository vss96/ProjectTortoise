{"gilded":0,"distinguished":null,"retrieved_on":1473809203,"author_flair_text":null,"author":"sickofthisshit","id":"cvrd8","edited":false,"parent_id":"t1_cvr8t","subreddit":"programming","score":12,"ups":12,"created_utc":1166806749,"author_flair_css_class":null,"body":"I have found a couple areas in which Python's dynamism is either more permissive or less pervasive than Lisp, where my development style has to adjust.\r\n\r\nExample 1: one can accidentally add properties to objects by mistyping a name, or create local variables. Lisp compilers will often warn about these: undefined function call detected, unused variable, argument count mismatches, etc. Python will just accept it. The calls of \"oh, yeah, do lots of unit tests\" gets a bit annoying. Testing to make sure you meet specs and interface guarantees to smooth integration and regression test after bug fixing is one thing, exhaustive testing to make sure you didn't make typos is another. Dynamism here has become \"anything goes.\"\r\n\r\nExample 2: reloading modules with changed methods on a class does not update the methods for already existing instances. Although the old instance's class has the same name, it has a different identity and different method dictionary, etc. Unfortunately, the error messages you get refer to the changed source file, often showing you the line of code you just corrected, but what executed was the previous version of that line. Pythonistas say \"oh yeah, get used to recreating or unpickling all the data while doing development, or go through some funky contortions to give Python the dynamism it deserves.\" I don't know how you are supposed to fix a running system.","controversiality":0,"subreddit_id":"t5_2fwo","stickied":false,"link_id":"t3_vr55","timestamp_epoch":1566236775,"message_id":"45656-b895f6ad-bfad-4679-92d5-4c141e3ee994-1566236775"}
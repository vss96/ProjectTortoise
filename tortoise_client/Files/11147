{"created_utc":1167424981,"author_flair_css_class":null,"ups":1,"score":1,"subreddit":"programming","stickied":false,"link_id":"t3_w79v","subreddit_id":"t5_2fwo","controversiality":0,"body":"Problem with filter is simply that Set.filter is O(n) while Set.map and Set.fromList are both O(n*log n). Its not a big difference, but in the end such things can count.\r\n\r\nAnd its not only really about Set.filter, its about what this problems says about the limitations of code reuse in Haskell. I'm not sure how this would work out if I have more experience in using Haskell but I'm no 'functional newbie' - only a Haskell newbie. If a language requires such effort to be used, its a reason to stay away from it.\r\n\r\n&gt; Monadic refactorization is an annoying task, and I wish that the tools for doing it automatically were available.\r\n\r\nThats the core of the problem. Of course different people weight it differently, some can live with it better than others. \r\n\r\nMaybe it would be enough to have a refactoring IDE for Haskell which can solve or at least ease this problem by asking a few questions in the refactoring process to do it at least semi-automatically. Or use another concept instead of monads or at least have the compiler to make it a bit more simple and reusable. \r\n\r\nI will of course continue to watch the developments in the Haskell community, maybe someone finds a solution. But to do work on it, the Haskell experts have to acknowledge the problem first (but there seem to be people who have done this and so I'm optimistic that there will be a solution sometimes).\r\n","retrieved_on":1473809635,"distinguished":null,"gilded":0,"edited":false,"parent_id":"t1_cwdev","id":"cwe6d","author_flair_text":null,"author":"kawa","timestamp_epoch":1566236779,"message_id":"57456-45cdddf2-88f3-4fe4-8fe7-e17d7309963c-1566236779"}
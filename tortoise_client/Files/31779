{"retrieved_on":1473808646,"distinguished":null,"gilded":0,"parent_id":"t1_cuwo9","id":"cuy9q","edited":false,"author_flair_text":null,"author":"pjdelport","author_flair_css_class":null,"created_utc":1166211973,"score":1,"ups":1,"subreddit":"programming","link_id":"t3_ujj3","stickied":false,"subreddit_id":"t5_2fwo","body":"Hrm, did you just edit and rewrite your message completely?  My other message was a reply to your previous question about multiple returns, which is now gone.\r\n\r\nIn any case, as for this question:\r\n\r\n&gt; Suppose Haskell didn't have the if-construct.\r\n\r\nYou don't need to suppose it;  Haskell's if \"construct\" is already just surface syntax for function application.\r\n\r\n&gt; How would you define \"if\" as a function in terms of function application using no other construct such that\r\n&gt; \r\n&gt; if x (print \"yes\") (print \"no\")\r\n&gt; \r\n&gt; works?\r\n\r\nJust the same:\r\n\r\n    if x a b = case x of\r\n                    True -&gt; a\r\n                    False -&gt; b\r\n\r\n&gt; It is cheating to use pattern matching - since matching a value agains a series of patterns is specified to happen in a given order\r\n\r\nNo.  Pattern precedence only matters if the patterns actually overlap, which is not the case here.  (In other words, banning pattern precedence/overlapping will have no effect on the example.)\r\n\r\nIt is also possible to contrive an arbitrary number of non-pattern-matching equivalents (for example, `if x a b = [b, a] !! fromEnum x`), but this is missing point:  the relevant thing remains functional dependency.","controversiality":0,"timestamp_epoch":1566236769,"message_id":"31225-5093f4c1-f950-4e54-bbf1-3613ecf7b4c3-1566236769"}
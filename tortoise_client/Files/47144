{"distinguished":null,"retrieved_on":1473808581,"gilded":0,"id":"cuurp","edited":false,"parent_id":"t1_cuu2j","author":"cgibbard","author_flair_text":null,"score":5,"ups":5,"created_utc":1166153184,"author_flair_css_class":null,"subreddit":"programming","subreddit_id":"t5_2fwo","stickied":false,"link_id":"t3_utz4","body":"This is something which as a Haskell programmer, I have found few answers for.\r\n\r\nI suppose that a sufficiently general system for flexible syntax would allow for merging some of the existing syntax sugar into the libraries, which while interesting, opens up the floor for Haskell to become a much more confusing language in which to program. If you can define list comprehension syntax in a library, you can probably define whatever syntax you like. I'd prefer going the other way and defining the list comprehension syntax in terms of the MonadZero class, which unfortunately was removed in Haskell 98, but I think everyone sees that was a mistake now. That would allow monad comprehensions to mean a variety of related things depending on monad.\r\n\r\nHowever, if you disregard syntax sugar, the major sort of thing where metaprogramming tends to be needed at the moment is in the automatic construction of large groups of record data structures from some external description file. (This may be helped somewhat through the inclusion of [proper records](http://www.cs.uu.nl/~daan/download/papers/scopedlabels.pdf) in Haskell.)\r\n\r\nI've seen it used in automatic construction of FFI imports from C/C++ header files, to moderate success. (Usually, more needs to be done than simple importing to create a library which picky Haskell programmers would really enjoy using.)\r\n\r\nI've also seen some clever uses of Template Haskell for doing some computations at compile time in order to improve runtime performance, simply by wrapping bits of the code which you want to run at compile time in splices.\r\n\r\nMost of the more fun and imaginative uses for macros seem to be covered by the pervasive use of laziness in combinator libraries (esp. monads). In a lazy language you essentially get to design your own control structures with no additional magic, because nothing which you don't want to have evaluated too soon is going to be evaluated anyway, so you don't have to write macros for special forms to wrap things up in extra function calls in order to prevent them from evaluating too soon.\r\n\r\n(One way to think about monads is as a way to abstract common control structures you might want to define in a certain variety of types of combinator library and make them polymorphic, so that they can be shared across all such libraries.)\r\n","controversiality":0,"timestamp_epoch":1566236769,"message_id":"29658-7c9a7f77-b6e4-4b4f-89ca-d993475f15a5-1566236769"}
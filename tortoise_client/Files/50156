{"author":"sbrown123","author_flair_text":null,"edited":false,"id":"cul66","parent_id":"t1_cukm7","gilded":0,"retrieved_on":1473808403,"distinguished":null,"controversiality":1,"body":"&gt;Well they support custom attribute processors now, but I'm not sure how much they can actually do. \r\n\r\nJava 6 includes an implementation of JSR 267.  But, from what I am reading, they missed the boat with it and produced something that only supports \"pluggable\" build time processing.  IMOH they should have focused on creating runtime processing first (like .NET already has)\r\n\r\nJoe Darcy explains the difference between both runtime and buildtime processing:\r\n\r\n&gt;\"    Build-time annotation processing occurs before compilation as part of the build process. For example, a source file under source code control could reference a superclass or subclass that will be generated by annotation processing. The generated and controlled files are then compiled together to produce the final program. Annotation processors can also be used to check for additional consistency constraints outside of the language specification, such as an integer annotation element being in a given range, like 1 through 10.\r\n\r\n&gt;    Runtime annotation processing uses core reflection to read the annotation values—using methods from the java.lang.reflect.AnnotatedElement interface—and take some appropriate action.\r\n\r\n&gt;    Both kinds of annotation processing are examples of meta-programming, that is, programming based on the structure of a program.\"","link_id":"t3_ujwh","stickied":false,"subreddit_id":"t5_2fwo","subreddit":"programming","author_flair_css_class":null,"created_utc":1165942066,"score":3,"ups":3,"timestamp_epoch":1566236767,"message_id":"25074-ce864011-94f3-49c4-9ee4-9234cf61f431-1566236767"}
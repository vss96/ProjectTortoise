{"gilded":0,"retrieved_on":1473808338,"distinguished":null,"author":"schwarzwald","author_flair_text":null,"edited":false,"id":"cuhrv","parent_id":"t3_ufir","subreddit":"programming","created_utc":1165876097,"author_flair_css_class":null,"score":5,"ups":5,"controversiality":0,"body":"the pattern matching in ML dialects really does come in handy.\r\n\r\nto give a real-world example, a widely cited 2001 face detection paper (google for \"Viola Jones\" if you're curious) implements a real-time face detection scheme and the speed largely stems from a clever representation scheme of an image they call the \"integral image\". if you represent your (grayscale for simplicity) image as a matrix of integers (each in [0,255]) then the idea is to compute at every point (x,y) the sum of all the pixels above and to the left. it turns out there's a fairly simple recurrence for this with the base cases being the far left (all pixels of the form (0,y) for some y) and the very top row (pixels of the form (x,0)). so to write out the code to compute this, you can just do something like this:\r\n\r\n    (* ... a few variable declarations and stuff here ... *)\r\n    let integral_image_aux x y = match (x,y) with\r\n      (x,0) -&gt; (* code for 1st base case goes here *)\r\n      | (0,y) -&gt; (* code for 2nd base case goes here *)\r\n      | (x,y) -&gt; (* general case formula goes here *)\r\n    (* ... code that calls the helper routine here ... *)\r\n\r\nusing OCaml 3.09 on a Pentium 4 2.8 Ghz it's fast enough to do the calculations for 150 640x480 images a second, fast enough for realtime.\r\n\r\n(the reason for the representation scheme is that you can compute means/standard deviations of any part of the image, of a window of any size, in constant time after computing the integral image of it.)","stickied":false,"link_id":"t3_ufir","subreddit_id":"t5_2fwo","timestamp_epoch":1566236766,"message_id":"23388-b619ccc0-dc6b-4e10-b680-12e8f95d05ee-1566236766"}
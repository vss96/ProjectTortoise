{"score":4,"ups":4,"author_flair_css_class":null,"created_utc":1164950017,"subreddit":"programming","subreddit_id":"t5_2fwo","link_id":"t3_t6gz","stickied":false,"controversiality":0,"body":"First off, it's never too late to change directions.  I switched majors from physics to CS in my last semester at college.  Yes, the department was pissed.  Yes, they said \"Absolutely not\" when I asked if I could.  They let me anyway, though they delayed my official graduation a semester so that I was officially a CS major for a year (which didn't really matter, since I finished courses on time and could go get a job).  Be prepared to work like a dog though.\r\n\r\nAnyways, to compete with recent computer science graduates in the workforce, you will need to know:\r\n\r\n* The language that your prospective employer's looking for.  This will usually be one of: C++, Java, C#, or PHP.  Python, Perl, and Ruby are also often useful.  Typical CS undergrads will usually only know C++ or Java, plus a few languages that are useless in industry.\r\n* The basics of recursion and pointers.  Most CS grads have forgotten these, but they are taught in class, so you look good if you remember them.\r\n* Data structures.  Specifically, you'll need to understand linked lists, binary search trees, vectors, hashtables, possibly heaps, basic complexity theory and big-O notation.\r\n* Simple algorithms.  Sorting is important - you need to know how bubble sort, insertion sort, selection sort, merge sort, and quick sort work, and how to select the correct one for the problem.  Extra points for bucket sort or radix sort.  You will never ever have to write a sorting algorithm once you actually get the job, but it's expected that applicants can do it on a whiteboard.  You should also know binary search.  Many algorithm courses spend a good deal of time on graph algorithms - shortest path, all-pairs shortest path, minimum spanning trees, depth-first search, breadth-first search, etc.  These are also rarely used in industry, but occasionally an interviewer will give you a graph problem as an interview question.\r\n* Concurrency.  For some reason, I got this question from all my prospective employers, and I give it to almost all my interviewees (maybe because I was looking in the financial industry).  You'll be expected to know some of the problems that arise with concurrent programs - deadlocks, race conditions.  You'll also be expected to know some of the common solutions to these problems - synchronized methods (monitors), semaphores, message queues, and so on.\r\n\r\nThat's basically all that the average CS undergrad knows.  As you can see, I hold a fairly dim view of average CS undergrads.  So here are some things that the typical CS undergrad does *not* know that will be useful to a practicing programmer:\r\n\r\n* IDEs.  Go download Eclipse or Netbeans and play with it.  Most interviewers will want to know what tools you are familiar with - not because they really care, but because knowing *any* of them indicates you've worked on practical programs, and that matters.  Also learn how to use the debugger on your favorite IDE (or gdb if you're an emacs + shell person), because you'll be spending *a lot* of time with it.\r\n* Version control.  Absolutely essential for the working programmer.  All version control systems basically work the same; the interviewer cares more that you have experience with at least one, so you don't try to grab the files you need off another developer's desktop and e-mail them to yourself (as I did at my first job).  The big open-source ones are Subversion and CVS; other popular programs include Visual SourceSafe, Perforce, and Darcs.\r\n* Build systems.  The Java world uses Ant, the C/C++ world uses make, the Haskell world uses Cabal, but you will never encounter Haskell in the real world.  Learn one of those two.  You likely won't be asked about this (most companies have a build system already setup), but you will want to know it when you start work.\r\n* Libraries and toolkits.  Having experience with *one* big framework is a plus, because it shows that you can navigate API docs and link against foreign code and know how to search for appropriate libraries.  I'd pick *one* GUI library and learn it well - some of the big ones are Swing (Java), SWT (Java), .NET (C#/VB/C++), MFC (Windows C++), native Win32 API (Windows C/C++), GTK (UNIX C), QT (UNIX C++), wxWindows (cross-platform C, with bindings for Python and probably many other languages), and Tk (C, I think, with bindings for just about every language).  For networking, learn BSD sockets because it's the base for just about every network library.  Learn the standard file-handling functions for your language of choice.  If you can, learn about mmap and memory-mapped files, and about asynchronous IO via select/poll/epoll.\r\n* Learn regular expressions.  Most uses of them are really horrible abuses that get you in more trouble later (Jamie Zawinski: \"Some programmers, when faced with a problem, think 'I know!  I'll just use regular expressions!'  Now they have two problems\").  However, they're very good for quick-and-dirty text munging.  Besides, they're theoretically interesting, and some interviewers (i.e. me) like to give out problems involving the theoretical structure of regexps.\r\n* UNIX.  You need to be able to get around via the command line.  Interviewers will probably not ask you this, you'll just feel stupid when you start and don't know how to get around the servers.  You don't need to be an expert sysadmin (unless you're applying for a sysadmin position).  You do need to be able to move around in directories, copy files, edit files, compile things, set environment variables, etc.\r\n* vi (the editor).  Yeah, emacs vs. vi is a holy war.  I don't care - just about every UNIX machine has vi installed, which makes it essential for quick &amp; dirty file editing.\r\n* Design Patterns.  It'll make you sound smart.  Also, it's nice to have a common vocabulary for discussing proposed solutions.\r\n* Refactoring.  You need to get into the habit of doing this automatically, else your code will suck.  If you want a good vocabulary for it, pick up the Martin Fowler book.  Fundamentally, you don't need this - refactoring can be summed up with \"If something sucks, fix it\", and you'll usually have a good intuitive sense for what's sucky code (hint: if you can't understand it, nobody else can either).  But the Fowler book will help you understand the IDE tools for this better, and again, it's useful for communication.\r\n* Write programs.  Startups are very good.  So are internships and open-source projects.  Make sure you have something to show for your efforts; many places will ask for code samples.\r\n\r\nAdditionally, here are some things that you will never, ever use in the real world, yet will mightily impress a smart interviewer.  Most potential employers will go \"Huh?\" if you mention one of these, but if you find one that goes \"Oh, cool!\" and goes off on a tangent with you, you'll know that it's full of smart people:\r\n\r\n* Advanced languages.  Learn Lisp - Scheme is probably easier to start with, but you can learn Common Lisp if you're feeling ambitious.  Then learn Erlang or SML to get used to pattern-matching, and maybe Ocaml for more practice.  Then you're ready to tackle Haskell, which is about the most advanced non-toy language out there.  \r\n* Functional programming.  Learn to program without using mutable state - all the advanced languages above are functional ones.  Not only does it sound cool, but it will change the way you think about problems in imperative languages.  You learn how to solve problems in Haskell, and you'll have many fewer bugs in Java.\r\n* Type theory.  The added rigor this brings to your thought process will make you much stronger at solving problems.  Plus, you won't get scared if someone says \"Curry-Howard isomorphism\" or starts talking about existential types or generalized algebraic data types.\r\n* Theoretical models of computer programming.  Personally I'm partial to lambda calculus, as it's the basis for all these functional programming languages.  Turing Machines are nifty too, though.  Also make sure you understand the Halting Problem and what it means for a problem to be undecidable, what it means for it to be NP-complete, and what it means to have a polynomial-time algorithm.\r\n* Process calculi.  These are formal models of concurrency.  Communicating Sequential Processes is probably the easiest to understand.  The pi calculus is the basis for much of the more recent work, and there's also new stuff like the join calculus.\r\n* Compiler and operating system design.  Learn about lexing, parsing, typechecking, intermediate representations, register allocation, activation records, and instruction selection.  Learn about pipelining, branch prediction, and cache misses.  Learn about scheduling, virtual memory, interprocess communication, and filesystem structure.  It's helpful to understand what's going on at the bits &amp; bytes level, particularly if you ever have to optimize things.\r\n\r\nHave fun Googling.  Also, I can give you some book recs if you want.","distinguished":null,"retrieved_on":1473807461,"gilded":0,"edited":false,"id":"ct6y7","parent_id":"t1_ct6h7","author":"nostrademons","author_flair_text":null,"timestamp_epoch":1566236758,"message_id":"603-465498cd-76a4-49f5-a42c-66d2b477245c-1566236758"}
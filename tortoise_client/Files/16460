{"retrieved_on":1473807957,"distinguished":null,"gilded":0,"edited":false,"parent_id":"t3_twtt","id":"ctxgd","author":"nostrademons","author_flair_text":null,"author_flair_css_class":null,"created_utc":1165459359,"ups":22,"score":22,"subreddit":"programming","link_id":"t3_twtt","stickied":false,"subreddit_id":"t5_2fwo","controversiality":0,"body":"I'm skeptical, though if it is, it would seem to confirm my characterization of FP as \"finishing the job that Dijkstra and Wirth and Knuth started\".  Moving from assembly -&gt; HLLs offered an order of magnitude improvement because it eliminated control flow errors.  Moving from manual memory management -&gt; garbage collection eliminated memory management errors.  Moving from procedural/OOP -&gt; FP eliminates the possibility of state errors.\r\n\r\nI'd hope that FP advocates don't succumb to the hype temptation though, and instead *show* people what it can do by writing cool programs.\r\n\r\nIn that vein (and because it happens to be on my terminal window and I want to record it before it scrolls off), I'm going to offer my complete bug count for an interpreter I just wrote in Haskell for a stack-based language.  It's about 500 lines of Haskell, 2/3 of which is in stack-manipulation primitives (I copied Factor's API, though I'm thinking of making it simpler):\r\n\r\n1. Lexer error.  Forgot to include whitespace as a possible input character.\r\n2. Lexer error.  Inside quotations (unevaluated code blocks), I forgot to allow +-/* characters.\r\n3. Show error.  Was pretty-printing symbols as \\wordName after I'd switched the lexical syntax to :wordName\r\n4. Monad transformer error.  I had defined my intepreter monad as ErrorT(StateT(IO)), when what I really wanted was StateT(ErrorT(IO)).  The former forgets the state when an error occurs; the latter keeps it and just marks the value as an error.\r\n5. Monad error.  I had been `catchError`ing only around a single getStack action, when I really wanted to wrap the whole eval procedure and catch errors.  As a result, the program exited out with no error message instead of printing the error and continuing.  Fix only took 2 parentheses, but this one was very difficult to track down.\r\n6. Lexer error.  Inside a quotation, I was lexing all tokens  as words, ignoring the possibility that they could also be literals.  As a result, it was giving me \"Undefined word: '1'\" when it should just have pushed 1 onto the stack.\r\n7. Lexer error.  I had not accounted for the possibility of nesting quotations, and so had to add [ and ] to the legal characters inside a quotation.  (Actually, I'm wondering if this'll cause problems later and I really need to add a full-fledged parser instead of a recursive lexer.)\r\n8. \"Pattern match failure in do expression at ./Primitives.hs:66\".  Yeah, this was caused by #7.  Fixed by adding a super-simple 3 line recursive descent parser and not attempting to handle balanced brackets in the lexer.\r\n9. Forgot to call the parser from the main lexing function.  Oops.\r\n\r\nThe interesting thing about these is that they're *all* logic errors.  If I were writing this in C, my first few bugs would likely be core dumps or access violations.  If it were Java, I'd expect a few NullPointerExceptions.  In both cases, I'd expect to see several \"Oops, those statements should be reordered\" or \"Damn, I forgot that this variable could be 0\" errors.\r\n","timestamp_epoch":1566236762,"message_id":"13013-0f39e7fa-c0b8-4db6-9136-57ef9b7081e1-1566236762"}
{"parent_id":"t1_cu6br","edited":false,"id":"cu99k","author":"grauenwolf","author_flair_text":null,"retrieved_on":1473808178,"distinguished":null,"gilded":0,"stickied":false,"link_id":"t3_u5jo","subreddit_id":"t5_2fwo","controversiality":0,"body":"I came accross this passage while reading the Haskell link dons provided:\r\n\r\n&gt; Consider the simple issue of reading a character from the user. We cannot simply have a function readChar :: Char, because it needs to return a different character each time it is called, depending on the input from the user. It is an essential property of Haskell as a pure functional language that all functions return the same value when called twice with the same arguments. But it is ok to have an I/O function getChar :: IO Char in the IO monad, because it can only be used in a sequence within the one-way monad. There is no way to get rid of the IO type constructor in the signature of any function that uses it, so the IO type constructor acts as a kind of tag that identifies all functions that do I/O. Furthermore, such functions are only useful within the IO monad. So a one-way monad effectively creates an isolated computational domain in which the rules of a pure functional language can be relaxed. Functional computations can move into the domain, but dangerous side-effects and non-referentially-transparent functions cannot escape from it. \r\n\r\nBecause of the requirements of the language, the simple act of reading key strokes becomes significantly more complicated.\r\n\r\nThis is why non-FP programmers often consider Monads Haskell to be a needlessly complicated hack.\r\n","created_utc":1165691072,"author_flair_css_class":null,"score":-4,"ups":-4,"subreddit":"programming","timestamp_epoch":1566236764,"message_id":"18804-cf758d31-5594-4a17-a836-f954d694c6eb-1566236764"}
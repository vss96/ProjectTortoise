{"gilded":0,"retrieved_on":1473809751,"distinguished":null,"author_flair_text":null,"author":"Brian","id":"cwkbh","edited":false,"parent_id":"t1_cwipg","subreddit":"programming","author_flair_css_class":null,"created_utc":1167591180,"score":1,"ups":1,"body":"&gt;Even before functional languages meant \"no assignments and no side effects\", they meant \"everything is an expression\".\r\n\r\nThis isn't quite true.  Functional programming has pretty much always been about no side-effects.  Having a difference between expressions and statement is more of a consequence of this than anything fundamental (and also due to the lisp heritage of many such languages where this *is* of central importance.)\r\n\r\nStatements usually imply sequencing - ie execute statement 1, **then** execute statement 2, but unless you're either doing something with the result of statement 1, or it had some other effect, then there wasn't any point in doing it.  If it did have some effect (eg storing the result in a variable), then you've introduced a side-effect.\r\n\r\nIt is, however, perfectly possible to have statements in a functional For example, the \"do\" syntax sugar Haskell provides for monadic operations could be considered to introduce statements - this wraps the sequentialness of the operations in imperative looking sugar while preserving functional purity \"under the hood.\"","controversiality":0,"link_id":"t3_wg1e","stickied":false,"subreddit_id":"t5_2fwo","timestamp_epoch":1566236780,"message_id":"60505-f001d999-929e-4bb0-918b-4d0d6bea3252-1566236780"}
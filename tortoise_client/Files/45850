{"distinguished":null,"retrieved_on":1473808468,"gilded":0,"parent_id":"t1_cuop8","edited":false,"id":"cuor1","author_flair_text":null,"author":"phil_g","score":1,"ups":1,"author_flair_css_class":null,"created_utc":1166036759,"subreddit":"programming","subreddit_id":"t5_2fwo","link_id":"t3_uh01","stickied":false,"controversiality":0,"body":"For one thing, in terms of general implementation details, Lisp has a tendency to provide multiple implementations of similar things, leaving it up to the programmer to pick the best set of tradeoffs.  Vectors (one-dimensional arrays) have O(1) access time and it's easier to modify their inner elements, but it's harder (or at least more expensive) to alter their size or deal regularly with nested arrays.  Lists make it easier to add and remove elements from the head (and from the tail, though it's a little harder) and generalize into binary trees easily, but have O(n) access.  If you want to support both, there are more generic functions that operate on sequences, which can be either lists or vectors.\r\n\r\nFor another thing, the generalization of lists into trees is a very important feature of Lisp lists, since Lisp's uncompiled code representation is simply a tree (and the operation of macros depends on this representation).  Thus, the experience gained from doing simple list manipulation is applicable to the more abstract levels of Lisp programming.","timestamp_epoch":1566236767,"message_id":"26732-a0a46011-4fc2-4e80-b3a5-47dbf439e624-1566236767"}
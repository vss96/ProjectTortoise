{"subreddit_id":"t5_2fwo","link_id":"t3_u5jo","stickied":false,"controversiality":0,"body":"I wonder about this a lot.  It seems the driving force behind the design of these languages is to abstract away all the details of specific computer architecture and leave behind a clean and pure computational system that is elegant and context independent.  Something that could be used by mathematicians to do bewildering computational tricks without them having to worry about file formats and network protocols.  But this seems to be precisely their downfall, is that programming languages are used, in the \"real world\", to deal with all of the things that ARE computer specific:  networking, files, processes, input/output, graphics, sound etc, all of which depend on the actual system you are using.  The perfect example is Haskell, which in its \"purest\" form cannot even do input/output because io functions return different values with the same arguments, something Haskell has to avoid if it is to be considered a pure functional language (but of course can be worked around with monads).  This is why C is still very useful, because it talks in the language of the machine, with just enough abstraction to relieve some of the annoyances of assembly (which is also still useful, actually, still necessary).  The more details of the machine are abstracted away, the more beautiful and elegant the language becomes, but also the less control you are left with over WHAT THE MACHINE IS ACTUALLY DOING.  A lot of the time this is okay, but when it matters, it is CRITICAL that you have the ability to control every change to every bit in your system.  A lot of languages have attempted to be \"platform neutral\" with more or less success, but in the end they all have to appeal to C or assembly programs which actually do the things that the language itself shies away from because it would taint the \"purity\" of the language.  \r\n\r\nAll of that said, I love scheme/haskell/Oz(!) and wish I could use them for \"real\" applications.  Oz especially with its amalgamation of haskell declarativeness and erlang concurrency and prolog constraint programming makes my mouth water!  And yes you can open files and sockets in all of these programs, but without solid file/process/graphics/windowing (and I don't mean TK)/real time/networking/data transfer libraries (which would all probably be written in C or assembly) they just don't have what it takes to really be useful in the \"real world\".  This is why C++ and java (or C# too now I guess) dominate the development world.  It is not because they are pretty languages (HA!) or maximally expressive or elegant or any of the things that we obviously value in a programming language.  It is because they can DO ANYTHING.  Can we not band together and give Haskell or Oz or Scheme the appropriate libraries so that they can actually compete in \"real world\" applications?  (And hey, if you can prove me wrong and show me that libraries that let me do all of these things already exist, then I will be the happiest guy in the world! (the \"real world\" that is))","score":9,"ups":9,"author_flair_css_class":null,"created_utc":1165608279,"subreddit":"programming","id":"cu5rv","edited":false,"parent_id":"t1_cu5k2","author_flair_text":null,"author":"patchwork","distinguished":null,"retrieved_on":1473808113,"gilded":0,"timestamp_epoch":1566236763,"message_id":"16853-ace162fc-fae1-4be3-b7c8-1f8e8f43b2bb-1566236763"}
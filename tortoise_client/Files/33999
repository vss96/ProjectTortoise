{"distinguished":null,"retrieved_on":1473807825,"gilded":0,"edited":false,"id":"ctqcz","parent_id":"t1_ctp28","author":"muleherd","author_flair_text":null,"score":2,"ups":2,"author_flair_css_class":null,"created_utc":1165344731,"subreddit":"programming","subreddit_id":"t5_2fwo","link_id":"t3_to4l","stickied":false,"controversiality":0,"body":"&gt; Full closures are already implementable in Java. It's just a matter of syntax.\r\n\r\n[Gafter's blog](http://gafter.blogspot.com/2006/09/debate-over-closures-for-java.html)  mentions what he considers this proposal's advantages.\r\n\r\n&gt; First, all local variables in outer nested scope entering a Java closure must be declared final. This is a profoundly stupid rule with no good justification.\r\n\r\nI'm guessing it simplifies implementation. An instance of an anonymous inner class may outlive the stack frame of the method invocation which created it, but the inner class must  still be able to use that invocation's stack-allocated variables. If these variables are final, they can simply be copied into the inner class.\r\n\r\n&gt; If a decent Java compiler were to check when our variables musn't be final, it could do this for us.\r\n\r\nCertainly, but IIRC the parties involved were once hesitant to use implicit heap allocations (i.e. those w/o the *new* keyword).\r\n\r\n&gt; This might be useful in many contexts; but closures are more than single functions (though the ruby and python folks don't know that). They can be GROUPS of functions which SHARE a common lexical variable\r\n\r\nDon't the functions in this Ruby snippet share a lexical variable?\r\n\r\n    def foo(n)\r\n       [lambda { n += 1 }, lambda {n -= 1 }]\r\n    end\r\n\r\n    incr, decr = foo(0)\r\n\r\nYou can do the same thing in Python (minus the silly issue with its scoping).","timestamp_epoch":1566236761,"message_id":"9543-a7e3e5a7-2e5d-4f74-b57f-8c63171a56b5-1566236761"}
{"gilded":0,"retrieved_on":1473809067,"distinguished":null,"author":"mhietajarvi","author_flair_text":null,"edited":false,"parent_id":"t1_cvjos","id":"cvk9g","subreddit":"programming","author_flair_css_class":null,"created_utc":1166659199,"score":14,"ups":14,"controversiality":0,"body":"\r\n\r\n\\tstatic int lookup_exp[2048];\r\n\\tstatic int lookup_mant[4096];\r\n\\tstatic float lookup_mult[2048];\r\n\r\n\\t/* Initialize lookup tables which enable us to calculate\r\n\\tpretty good first estimate of the root */\r\n\\tvoid cuberoot_init(void)\r\n\\t{\r\n\\t\\tint t;\r\n\r\n\\t\\t/* Basic idea is this:\r\n\\t\\toriginal number = mant * 2^exp\r\n\\t\\tits inverted cuberoot = 1.0/cbrt(mant * 2^exp)\r\n\\t\\t\\t\\t\\t\\t\\t\\t= 1.0/cbrt(mant) * 2^(-exp/3.0)\r\n\\t\\t\\t\\t\\t\\t\\t\\t= 2.0/cbrt(mant) * 2^(-exp/3.0 - 1)\r\n\\t\\texponent is divided to two parts: (integer &amp; fractional exponents)\r\n\\t\\t2^(-exp/3.0 - 1) == 2^(-exp/3 - 1) * (2^(-exp/3.0)/2^(-exp/3))\r\n\\t\\t(division by 3.0 produces a double, division by 3 an integer (rounded towards 0))\r\n\\t\\t(-1 because mantissa gets multiplied by 2, for reason to this look at mantissa table) */\r\n\r\n\\t\\t/* lookup_exp and lookup_mult are accessed using the raw 11 exponent\r\n\\t\\tbits of a double value, so there are 2048 possible values */\r\n\\t\\tfor (t = 0; t &lt; 2048; t++)\r\n\\t\\t{\r\n\\t\\t\\t/* The actual exponent is found by unbiasing the raw number */\r\n\\t\\t\\tint exp = t - 0x3FF;\r\n\r\n\\t\\t\\t/* (-exp/3 - 1) = integer exponent, which can be directly\r\n\\t\\t\\tplaced into the double in memory */\r\n\\t\\t\\tlookup_exp[t] = (((-exp/3 - 1) + 0x3FF) &amp; 0x000007FF) &lt;&lt; 20;\r\n\\t\\t\\t/* (exp/3 - exp/3.0) = fractional exponent giving additional\r\n\\t\\t\\tmultiplier since float accuracy is enough (tested), float\r\n\\t\\t\\tis used to cut down table size */\r\n\\t\\t\\tlookup_mult[t] = (float) (pow(2.0, (exp/3 - exp/3.0)));\r\n\\t\\t}\r\n\\t\\t/* lookup_mant is indexed by the first 12 bits of the mantissa\r\n\\t\\t(since the real mantissa is cut after 12 bits, we assume\r\n\\t\\t\\tthat 13th bit is one and bits after that are zero, so that\r\n\\t\\t\\tthe rounding error is minimized)\r\n\\t\\t(h = 0.5/4096, corresponding to the value of 13th bit) */\r\n\\t\\tfor (t = 0; t &lt; 4096; t++)\r\n\\t\\t{\r\n\\t\\t\\t/* This is simply approximation of the inverse cuberoot of the normalized mantissa.\r\n\\t\\t\\tNormalized mantissa, cut to 12 bits after the first 1 has range [1.0 + h, 2.0 - h],\r\n\\t\\t\\tso its inverse cuberoot = [0.79, 0.99996], which we have to multiply by two to\r\n\\t\\t\\tget again normalized range = [1.59, 1.9999] (and subtract one to get just the\r\n\\t\\t\\tfractional bits) (this is the reason for the 2 multiplier in the original formula!)\r\n\\t\\t\\tOnly the first 20 bits are stored, and the last 32 bits of double precision value\r\n\\t\\t\\tcan be arbitrary (0x80000000 would give best accuracy, but we get double precision\r\n\\t\\t\\taccuracy anyway, so there's no reason to bother).\r\n\\t\\t\\t(no more bits was needed to get double accuracy with two iterations, and\r\n\\t\\t\\tthere is no point using more unless also more bits are used to access the table in\r\n\\t\\t\\tthe first place (instead of 12 bits at least 24 would have to be used, resulting in\r\n\\t\\t\\ta minimum table size of 64MB!!!) */\r\n\r\n\\t\\t\\tlookup_mant[t] =\r\n\\t\\t\\t\\t((int) ((2.0 * pow((0.5 + (double) t)/4096 + 1.0, -1.0/3.0) - 1.0)*(0x100000)));\r\n\\t\\t}\r\n\\t}\r\n\r\n\r\n\\t/* Relatively fast cuberoot algorithm utilizing look-up tables,\r\n\\tsome bit manipulation and Newton's method. Actually this is\r\n\\talso more accurate than using pow or log/exp! */\r\n\\tdouble cuberoot(double val)\r\n\\t{\r\n\\t\\tif (((int *)&amp;val)[1] == 0)\r\n\\t\\t\\treturn 0.0;\r\n\\t\\tdouble tmp;\r\n\\t\\tfloat mult;\r\n\\t\\t__asm\r\n\\t\\t{\r\n\\t\\t\\tmov eax,dword ptr [val+4]\r\n\\t\\t\\tmov ebx,0x80000000 /* only sign bit is untouched */\r\n\\t\\t\\tmov edx,0x000FFF00 /* mantissa index mask */\r\n\\t\\t\\tand ebx,eax\r\n\\t\\t\\tand edx,eax\r\n\\t\\t\\tand eax,0x7FF00000 /* exp &amp; multiplier index mask */\r\n\\t\\t\\tshr eax,20\r\n\\t\\t\\tshr edx,8\r\n\\t\\t\\tor  ebx,lookup_exp[eax*4]\r\n\\t\\t\\tmov eax,lookup_mult[eax*4]\r\n\\t\\t\\tor  ebx,lookup_mant[edx*4]\r\n\\t\\t\\tmov mult,eax\r\n\\t\\t\\tmov dword ptr [tmp+4],ebx /* write first estimate into tmp */\r\n\\t\\t}\r\n\\t    \r\n\\t\\ttmp *= mult; /* correct for the fractional part of exp/3.0 */\r\n\r\n\\t\\t/* two iterations is enough for full double precision accuracy */\r\n\\t\\ttmp = (1.0/3.0)*tmp*(4.0 - val*tmp*tmp*tmp);\r\n\\t\\treturn (1.0/((1.0/3.0)*tmp*(4.0 - val*tmp*tmp*tmp)));\r\n\\t}\r\n","link_id":"t3_vi33","stickied":false,"subreddit_id":"t5_2fwo","timestamp_epoch":1566236774,"message_id":"42128-8a81ffec-cb66-449b-919c-fcaf7575a802-1566236774"}
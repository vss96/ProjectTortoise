{"subreddit":"programming","score":2,"ups":2,"author_flair_css_class":null,"created_utc":1167236560,"body":"&gt; Each individual index may well be smaller, but cumulatively they will be larger\r\n\r\nThe expected spatial behavior of a b-tree index is O(n log n), iirc (actually, it varies based on the number of possible brother nodes, but in this example that will be constant).\r\n\r\nIn this example, we're looking at a system with at least 100M rows, broken out into 26 partitions. Whole-table vs. partitioned-table (assuming roughly equal-sized partitions) would look like:\r\n\r\n10^8 (log2 10^8)  vs.  26 (3.85 x 10^6 (log2 3.85 x 10^6))\r\n\r\nor about\r\n\r\n2.66 x 10^9  vs.  2.19 x 10^9\r\n\r\nSo the partitioned indices, even taken cumulatively, should still be smaller (by about 20%) than the total index. This space advantage shrinks as the distribution becomes less even (e.g. the \"starts with X\" table is going to be smaller than the \"starts with I\"). However, it should shrink asymptotically, remaining an advantage up until only two or fewer partitions have data (discounting the constant value of having an empty index).\r\n\r\nMore importantly, though, the individual indices can be more easily loaded into RAM for an index scan. This is even more relevant since he expects to be operating on multiple indices for any given query.\r\n\r\n&gt; I suspect if he tried it out with a single large table he'd be a tad surprised by the results.\r\n\r\nI agree. Mostly, i think it depends on the RAM overhead. If he can fit the relevant indices into RAM for each query, there shouldn't be much behavioral difference.\r\n","controversiality":0,"subreddit_id":"t5_2fwo","link_id":"t3_vzbb","stickied":false,"gilded":0,"distinguished":null,"retrieved_on":1473809477,"author_flair_text":null,"author":"jmelesky","edited":false,"id":"cw5rf","parent_id":"t1_cw3tp","timestamp_epoch":1566236778,"message_id":"53139-371cae28-eb69-4be9-8806-0c3255798edd-1566236778"}
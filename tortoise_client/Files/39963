{"body":"&gt; This is quite simple in theory but it can get ugly in practice. Many examples about monads even use an example of state-chaining to show how ugly it is and how you can make it pretty again if you use a state monad instead.\r\nAnd to really use it, you need lots of custom functions. Consider \"map f list\" for example. Without state easy to use, but later you discover that your f has to modify something of your chained state while mapping. Simply using \"map (\\v -&gt; f v st) list\" won't work because each computation gets a 'fresh' state instead of the state of the previous calculation now.\r\n&gt; So you have to write a new map function. But that not easy because map functions are one of the primary means of iteration in functional programming. Thus every non-trivial data-type has a map function which you can't simply modify. Now monads come in handy because they only require to be part of the result instead of part of argument and result.\r\n&gt; So it much more simple to use - but it still requires changing functions. Luckily a function like map can be lifted to monad form without touching the code. But this don't work with all types of functions. Look at 'filter :: (a -&gt; Bool) -&gt; b a -&gt; b a' function and tell me how to simply lift it to a monadic form. Maybe I'm blind and missed to obvious, but until now I haven't found a way.\r\n\r\nWell, there are very idiomatic ways around this!\r\nFirst, you have Functors, which are defined in Haskell as a type class with a single member fmap:\r\n\r\n    class Functor f where\r\n      fmap :: (a-&gt;b) -&gt; f a -&gt; f b\r\n\r\nDoes that look like *map*? that's because it is map generalised!\r\nNow, Functor has a long list of instances: [], Maybe, Either, IO....\r\nYes, liftM is fmap too. Every Monad is an instance of Functor.\r\n\r\nYou wanted to apply filter to a Set datatype right? We can't define filter in terms of fmap, for that we need a fold, which is the building block to define filter (and map can be defined in terms of fold too). In addition Set cannot be an instance of Functor, because it is not a Functor! Consider that the elements of a Set maintain an invariant, namely uniqueness, that can be invalidated after mapping an arbitrary function. \r\nSo while Set cannot be an instance of Functor, it is an instance of Foldable, another type class for identifying foldable data types, which has been recently discovered (yay, at least formally) and is tremendously useful and general. \r\n\r\n    class Foldable t where\r\n      fold :: Monoid m =&gt; t m -&gt; m\r\n\r\nOnce an arbitrary datatype is made an instance of Foldable, immediately you have available most of the well-known list processing functions for it: \r\n    :b Data.Foldable\r\n\r\n    concat :: (Foldable t) =&gt; t [a] -&gt; [a]\r\n    and :: (Foldable t) =&gt; t Bool -&gt; Bool\r\n    or :: (Foldable t) =&gt; t Bool -&gt; Bool \r\n    any :: (Foldable t) =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool\r\n    all :: (Foldable t) =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool\r\n    sum :: (Foldable t, Num a) =&gt; t a -&gt; a\r\n    product :: (Foldable t, Num a) =&gt; t a -&gt; a\r\n    maximum :: (Foldable t, Ord a) =&gt; t a -&gt; a \r\n    minimum :: (Foldable t, Ord a) =&gt; t a -&gt; a\r\n    notElem :: (Foldable t, Eq a) =&gt; a -&gt; t a -&gt; Bool\r\n    find :: (Foldable t) =&gt; (a -&gt; Bool) -&gt; t a -&gt; Maybe a\r\n    .....\r\n\r\nEven with this generality, it is not really possible to define a generalized version of filter; the most you can do is define a filter that takes a Set/Sequence/Map whatever and returns a *list* of the filtered elements: `filter . toList`. Note that `toList` comes for free with Foldable. And this solution is generally what you want.\r\n\r\nThe bonus is that you can define all your list processing functions in terms of Foldable instead of [],  and you end up with a nice amount of highly reusable code. If you still are feeling sane, check these references:\r\n&gt; http://www.soi.city.ac.uk/~ross/papers/Applicative.html\r\n&gt; http://web.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/index.html#iterator","controversiality":0,"subreddit_id":"t5_2fwo","link_id":"t3_w79v","stickied":false,"subreddit":"programming","score":2,"ups":2,"author_flair_css_class":null,"created_utc":1167388755,"author":"pepegg","author_flair_text":null,"parent_id":"t1_cwaud","id":"cwcgn","edited":false,"gilded":0,"distinguished":null,"retrieved_on":1473809603,"timestamp_epoch":1566236779,"message_id":"56560-c25d1781-eb02-4929-b9d9-39c3975eb110-1566236779"}
{"body":"The point is not to teach using a mainstream language, but to teach using a language which is good for teaching computer science.\r\n\r\nIf mainstream languages are taught, this is almost always due to political pressure, and usually not because people thought they were the best idea for actually learning about the theory of computation.\r\n\r\nOne important thing to note is that computer science is a total misnomer: It's neither a science (it's not empirical), nor is it about computers. It was named before it was well understood what it was that we were studying. Computer science is the mathematical study of processes of computation.\r\n\r\nWhat you really want when you're teaching a CS course is a language which helps in making concepts taught in the course clear to the student. You most certainly do not want a language where the semantics are unnecessarily difficult to reason about, and you don't want a language which requires too much attention to details irrelevant to the course, especially those which will be out of date in a few years.\r\n\r\nOn the other hand, there is always pressure from the outside world, and faculties always have to decide how much to cave in to this pressure. In the case of co-op programs, this pressure is often overwhelming, and often to the detriment of the program's quality.\r\n\r\nIn this regard, I don't think Python is a terrible compromise. It's sufficiently mainstream that it could conceivably be used in real-world applications. Personally, I favour Haskell as an initial programming language for CS students, because I really like the top-down approach to explaining CS, progressing toward lower-level details and potentially aspects of the hardware implementation later on. Of course, there are many more even less mainstream languages, but one usually wants something which is going to have a decent and usable set of tools, and so there is somewhat of a limit on obscurity.\r\n\r\nThere is at least one exception to that, and that's the possibility of designing a specific language tuned to the courses. This is not as unreasonable as it might initially sound. Once one understands the theory and concepts behind a language well enough, the specific syntactic details of the language are comparatively unimportant, and can usually be learned relatively quickly.\r\n\r\nOthers might take the bottom-up approach, but I find that infecting people's minds with the ideas of stateful computation and imperative computation too early tends to lead to making functional and declarative programming harder  on students later, while I haven't observed too much of the reverse: people who don't impose unnecessary ordering on computations to begin with usually have few problems imposing an arbitrary order on them when that's necessary, and avoiding excessive use of state is a good idea in essentially any language. (In things like assembly, it can't be avoided, but still one wants to minimise its reach in order to have a good hope of structuring programs in a manageable way.)\r\n\r\nJava is certainly not the right place to start. It has few solid advantages over other languages apart from market share, which should not be a concern for people who are studying computation. It is horrifically verbose, which detracts from being able to reasonably use it as a form of expression on paper or on a blackboard. C# is better in lots of ways, but not really by enough in the ways that matter for teaching.\r\n\r\nPHP is a horrible mess of a language, and I won't even bother talking about it.\r\n\r\nPerl, while it's good at what it does, is also a horrible mess from this perspective. Actually saying what a given Perl program will do formally is really difficult and mostly defined by the implementation, not to mention that the syntax is so complicated that the only thing which parses Perl is perl.\r\n\r\nC is good at certain points for teaching low-level aspects, but I really think there ought to be better options in that regard. It's also certainly not a good first language, as it requires attention to things which are entirely irrelevant to beginners.\r\n\r\nIf you're going to teach imperative and/or OO programming, I'd say Python and Ruby are your best bets from really mainstream stuff. Smalltalk is also a fairly decent language  in this regard if you're willing to go a little less mainstream.\r\n\r\nFor functional programming, there are lots of good options. Scheme is a really excellent language to start with, because there is a wealth of very high quality teaching material for it. SICP is really quite excellent, and it would be hard to go wrong with any course which was modelled after the MIT lectures.\r\n\r\nHaskell is also a decent language to start with because the reasoning involved is very equational and algebraic, and ties well with mathematics courses. It also has the virtue (!) of being very different from anything students are more likely to have seen in earlier years. This levels the playing field quite a bit, and gets students to think about computation in a new way whether they are new to programming or not. Lazy evaluation ties in nicely with a discussion about the various options for evaluation mechanisms in a language. Even moreso than with most functional languages, it also means that they will learn to program things without any unnecessary sequencing of operations or additional unnecessary state, for reasons which I've touched on above.\r\n\r\nAnyway, my whole point is really just that the languages which you might feel are appropriate for getting things done in the business world are not necessarily those which are best for students of the theory of computation, and this I feel is a really important point which is being missed or ignored even by some faculties.","controversiality":0,"subreddit_id":"t5_2fwo","link_id":"t3_t3xg","stickied":false,"subreddit":"programming","score":6,"ups":6,"author_flair_css_class":null,"created_utc":1164948123,"author":"cgibbard","author_flair_text":null,"edited":false,"id":"ct6ut","parent_id":"t1_ct67z","gilded":0,"distinguished":null,"retrieved_on":1473807458,"timestamp_epoch":1566236758,"message_id":"553-6b30e07f-2041-4c0e-81d3-973d203fc46d-1566236758"}
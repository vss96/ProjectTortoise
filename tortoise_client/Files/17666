{"edited":false,"parent_id":"t1_cureu","id":"cursi","author":"shit","author_flair_text":null,"distinguished":null,"retrieved_on":1473808525,"gilded":0,"subreddit_id":"t5_2fwo","link_id":"t3_uqnu","stickied":false,"body":"&gt; I'm really surprised. It doesn't use bytecode yet? WTF!?\r\n\r\nWhat improvements do you expect from bytecode? Speed? Python has a bytecode interpreter, yet it is not universally faster (I think this is a common myth) than Ruby. I've made a microbenchmark that measures a method call + instance variable assignment, which comes up a lot in Ruby and Python. First the Ruby version:\r\n\r\nFirst, measure an empty loop so that we can subtract the time later:\r\n\r\n     Benchmark.bm { |x| x.report { 1_000_000.times { } } }\r\n          user     system      total        real\r\n      0.310000   0.000000   0.310000 (  0.310602)\r\n    =&gt; true\r\n     Benchmark.bm { |x| x.report { 1_000_000.times { } } }\r\n          user     system      total        real\r\n      0.310000   0.000000   0.310000 (  0.309881)\r\n\r\nDefine a class:\r\n\r\n     class Foo\r\n       def initialize\r\n         @var = 0\r\n       end\r\n       def inc_var\r\n         @var += 1\r\n       end\r\n     end\r\n\r\nand invoke the inc_var method a million times:\r\n\r\n     f = Foo.new\r\n\r\n     Benchmark.bm { |x| x.report { 1_000_000.times { f.inc_var } } }\r\n          user     system      total        real\r\n      0.800000   0.000000   0.800000 (  0.825715)\r\n    =&gt; true\r\n     Benchmark.bm { |x| x.report { 1_000_000.times { f.inc_var } } }\r\n          user     system      total        real\r\n      0.810000   0.000000   0.810000 (  0.827129)\r\n    =&gt; true\r\n\r\nSo we have about 0.827 seconds minus 0.310 seconds loop overhead. Leaves 0.517 seconds for `f.inc_var` invocations.\r\n\r\nThe Python version:\r\n\r\nFirst, we define our own little timing function:\r\n\r\n    import time\r\n    def timeit(fun):\r\n      t0 = time.time()\r\n      fun()\r\n      t1 = time.time() - t0\r\n      print t1, \"seconds\"\r\n\r\nTime the empty loop:\r\n\r\n    def loop():\r\n      for i in range(0, 1000000): pass\r\n\r\n    timeit(loop)\r\n    0.230543136597 seconds\r\n    timeit(loop)\r\n    0.191242933273 seconds\r\n\r\nDefine the class:\r\n\r\n    class Foo:\r\n      def __init__(self):\r\n        self._var = 0\r\n      def inc_var(self):\r\n        self._var += 1\r\n\r\nand invoke the inc_var method a million times:\r\n\r\n    def loop_inc():\r\n      f = Foo()\r\n      for i in range(0, 1000000): f.inc_var()\r\n   \r\n    timeit(loop_inc)\r\n    1.11231589317 seconds\r\n    timeit(loop_inc)\r\n    1.08711910248 seconds\r\n\r\nWe have about 1.010 seconds minus 0.210 seconds loop overhead. Leaves 0.800 seconds for `f.inc_var` invocations.\r\n\r\nIn comparison, the Ruby times are only 64% of the Python times. The proportions stay roughly the same when I increase from one million to ten million iterations.\r\n\r\n(Python even has an advantage in this benchmark: You can redefine integer addition in Ruby, but not in Python.)","controversiality":1,"score":3,"ups":3,"author_flair_css_class":null,"created_utc":1166109546,"subreddit":"programming","timestamp_epoch":1566236768,"message_id":"28067-c14990ea-6b44-48da-a9b5-6000666d47fe-1566236768"}
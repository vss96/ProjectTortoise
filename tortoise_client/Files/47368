{"edited":false,"parent_id":"t1_cu4h5","id":"cu4s4","author_flair_text":null,"author":"rmtew","distinguished":null,"retrieved_on":1473808092,"gilded":0,"subreddit_id":"t5_2fwo","link_id":"t3_u2ng","stickied":false,"controversiality":0,"body":"&gt; There's a huge difference: Erlang uses message-passing, instead of shared state, for all inter-thread communication. It makes cooperative scheduling entirely redundant; preemptive threading is just as safe.\r\n\r\nYes, hence:\r\n\r\n&gt;&gt; I assume that the Erlang processes are reliable with preemptive scheduling because of the message passing concurrency.\r\n\r\n&gt; Despite their superficial similarity, you can't really compare Python and Erlang's threading. They're as different as (say) Scheme and Haskell's approaches to functional programming.\r\n\r\nI believe you mean Stackless' microthreading and Erlang's threading.  When I read the article I did which summarised Erlang's processes (linked in another of my comments), besides the message passing approach, it directly reminded me of Stackless' tasklets.  Ignoring of course the infrastructure and pervasive support for the lightweight threading which Erlang has and Stackless lacks.\r\n\r\nYour functional language comparison is a strawman argument and explains nothing to me.\r\n","score":0,"ups":0,"author_flair_css_class":null,"created_utc":1165595489,"subreddit":"programming","timestamp_epoch":1566236763,"message_id":"16263-ab53fe1e-fe97-47d8-a9e8-1acf4ed1b48f-1566236763"}
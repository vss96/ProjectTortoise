{"id":"cutyw","edited":false,"parent_id":"t1_cutry","author_flair_text":null,"author":"nostrademons","distinguished":null,"retrieved_on":1473808565,"gilded":0,"subreddit_id":"t5_2fwo","stickied":false,"link_id":"t3_ut6i","controversiality":0,"body":"Well, yes.  It all comes down to code-is-data, something made explicit in Lisp and machine language.  \r\n\r\nAnd if you consider variables as requirements for a language, you cut out lambda calculus, pure stack-based languages (Forth actually has variables, but they aren't absolutely necessary in the stack paradigm), Unlambda, Brainfuck &amp; variants, Malbolge, point-free Haskell, and some assembly languages.  If you mean variables in the stricter sense of *mutable* variables, you eliminate all of Haskell and Erlang.  Flow control eliminates the lambda calculus &amp; Unlambda.  If you mean imperative flow control (no cond statements or pattern matching), then there goes Lisp, Haskell, Ocaml, Erlang, Epigram, or any of the other languages that lack statements.","ups":17,"score":17,"created_utc":1166138641,"author_flair_css_class":null,"subreddit":"programming","timestamp_epoch":1566236769,"message_id":"29205-321e9247-cf01-419c-a572-a192e885959b-1566236769"}
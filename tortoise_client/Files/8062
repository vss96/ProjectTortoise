{"edited":false,"id":"cwa39","parent_id":"t1_cw9zs","author_flair_text":null,"author":"kawa","retrieved_on":1473809560,"distinguished":null,"gilded":0,"stickied":false,"link_id":"t3_w79v","subreddit_id":"t5_2fwo","body":"You described the theory very well, but in practice it often seems to be different.\r\n\r\nImagine you want to implement a interpreter for an imperative language: How can you factor an interpreter of this language into a set of referential transparent functions? You simply can't, unless you chain some kind of state thru your interpreter which catches all the mutations. \r\n\r\nThe 'core' of my project is a forward inference engine. Such a thing works by applying rules to a set of facts creating new facts - which in turn let other rules fire until the system gets to some steady end state. This mechanism requires mutation of the facts database, there's no way out.\r\n\r\nAnother part is a gui browser which allows to query the db and to assert new facts and new rules. How can this be done without mutation? \r\n\r\nAnother one is the compiler which compiles a language which describes the rules and facts into a runtime model checking (amongst others) certain constraints to be sure that the system will reach a steady state in the end. The algorithm for this creates and checks constraints until finding an error or exhausting. Asserting those constraints requires mutation. Assertion and evaluation are happening in the same pass because they often depend on each other, so this also requires mutation.\r\n\r\nYou see how mutation is part of the central core of many parts of the system. Sure, there are helper functions which are mutation free, but while I've written the code I often found out that some helper function requires access to some state which required the rewrite of the helper, often creating an avalanche of changes.\r\n\r\nYes, writing code in Haskell is slow. Writing 10 lines Haskell code requires in average maybe the same time then writing 50 to 100 lines of Java code (but in Java 50% or more of the code is autogenerated by the IDE). \r\n\r\nThis is no problem (far from it) until you have to rewrite 200 lines of Haskell code to allow access to some 'external'  state. And in one case I even discovered later that it wasn't even necessary because I misunderstood some part of the system at this time. So the work was in fact useless - but I was only able to discover that after I tried it out in the context of the whole of the program. \r\n\r\nBut thats quite normal if you design something new and also the reason for concepts like 'agile development' or 'extreme programming'. With Haskell this is quite problematic, because of the state problem. Maybe I could've simply used unsafe IO instead - but I wanted to write 'real' Haskell code and not using tricks and hacks.\r\n","controversiality":0,"created_utc":1167334876,"author_flair_css_class":null,"score":6,"ups":6,"subreddit":"programming","timestamp_epoch":1566236779,"message_id":"55382-974ad9ef-a26a-44ca-a11a-3078e4d42d30-1566236779"}
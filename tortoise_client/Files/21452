{"parent_id":"t3_w9y9","edited":false,"id":"cwckb","author_flair_text":null,"author":"notfancy","retrieved_on":1473809605,"distinguished":null,"gilded":0,"stickied":false,"link_id":"t3_w9y9","subreddit_id":"t5_2fwo","controversiality":0,"body":"A good summary/cheat-sheet of the introductory sections of the Bananas paper (linked to in the post).\r\n\r\nThis is a very important, if somewhat schizophrenic paper: it has a very accessible expository part, and a very hard formal part. The gist of it is that you often can abstract recursion schemes over inductive datataypes (even the integers!); if you do, you end up with the same functional \"shapes\", irrespective of the type you're recursing on.\r\n\r\nThis buys you two things, one of indirect importance, the other one more immediate. The immediate, practical gain is that they allow you to use recursion as another \"library function\". In particular, you don't have to reason inductively if you use the morphisms: they are equipped with algebraic laws that let you prove things directly, without resorting to induction.\r\n\r\nThe indirect gain is that simply-typed Lambda calculus forbids writing recursion operators (think of the Y combinator); if your language generates automatically the morphisms when definining the inductive datatypes, you can still do pretty much everything without resorting to general recursion, without the need to escape the simply-typed discipline. The added bonus is that your type system proves termination! This is, more or less, what [Epigram](http://www.e-pig.org/) strives to accomplish.","created_utc":1167394135,"author_flair_css_class":null,"score":4,"ups":4,"subreddit":"programming","timestamp_epoch":1566236779,"message_id":"56597-55626b66-6a5c-4e72-b836-539acf46afa9-1566236779"}
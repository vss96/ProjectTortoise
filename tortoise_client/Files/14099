{"stickied":false,"link_id":"t3_w79v","subreddit_id":"t5_2fwo","body":"There are two problem with showing code:\r\n\r\n- It's only a part of a whole\r\n- It's already finished so it looks 'easy'\r\n\r\nThe problem is not that it's impossible to create code which solves a certain problem. The problem is that the design process becomes more difficult if it requires to often complicated refactorings.\r\n\r\nWhat I want from a programming language is 'productivity': I want to be able to solve problem as fast as possible and I also want to be able to easily adapt the code to changing requirements. In most cases the latter don't happen because of a changed specification of the whole project but just because while implementing it I discovered that there were wrong assumptions about parts of the solution. For non trivial problems it seems impossible (at least for me) to foresee if a solution will really work or if there are additional problems I have to solve.\r\n\r\nIn Haskell finished code if often result of multiple iterations which made the code look rather concise. But this final state is reached via a series of experiments and simplifications. Thats probably the reason why the the code-lines/time ratio is rather small in Haskell compared to other languages.\r\n\r\nI have no problem with that, but I also don't think that resulting code size is a valid metric for anything. The only metric I value is the time it takes to implement something working. As I switched from C++ to Java some years ago I discovered a very good improvement ratio from 2-3 times. Even while code size increased slightly I got to a working result much faster.\r\n\r\nI haven't seen something like this in Haskell yet. I see a good improvement if I work with 'pure functional code'. But in the moment I require state the advantage turns into the opposite and it seems that I have to fight the language to accomplish things.\r\n\r\nI can continue the project and I will probably finish it, but if it takes more time as it would take in Java, why should I use Haskell then? True, I have to learn more about the language first and I do consider this but the problems don't seem to ease, instead they even seem to increase with the size of the code I have written because each change I have to do affects more existing code.\r\n\r\nBut even experienced Haskell users seems to acknowledge this. To quote from http://www.haskell.org/tmrwiki/FunWithLinearImplicitParameters, mentioned by cgibbard below: \"Haskell's do-notation is often criticized being too verbose, especially for commutative monads; and the process of transforming pure functions into monadic style because some (possibly deeply nested) function needs some effects is tedious and error-prone.\"\r\n","controversiality":0,"created_utc":1167395344,"author_flair_css_class":null,"score":2,"ups":2,"subreddit":"programming","edited":false,"parent_id":"t1_cwc8i","id":"cwcl3","author_flair_text":null,"author":"kawa","retrieved_on":1473809605,"distinguished":null,"gilded":0,"timestamp_epoch":1566236779,"message_id":"56605-f3ad8b63-5a91-4a3d-86cc-67b19524733a-1566236779"}
{"ups":9,"score":9,"author_flair_css_class":null,"created_utc":1166423427,"subreddit":"programming","subreddit_id":"t5_2fwo","link_id":"t3_v6bg","stickied":false,"controversiality":0,"body":"In order to stave off the inevitable flow of `chunk` implementations...\r\n\r\n    chunk n xs = map (take i) . takeWhile (not . null) . iterate (drop i) $ xs\r\n       where i = (length xs - 1) `div` n + 1\r\n\r\nfollowed by the less efficient (but shorter):\r\n\r\n    chunk n = transpose . map (take n) . takeWhile (not . null) . iterate (drop n)\r\n\r\n`unfoldr` allows for the particular ugly:\r\n\r\n    chunk n = transpose . unfoldr (liftM2 (&gt;&gt;) (guard . not . null) (return . splitAt n))","distinguished":null,"retrieved_on":1473808805,"gilded":0,"id":"cv6mb","edited":false,"parent_id":"t3_v6bg","author_flair_text":null,"author":"glguy","timestamp_epoch":1566236771,"message_id":"35287-7f193795-5df6-42f1-878a-41f797d1909e-1566236771"}
{"subreddit":"programming","author_flair_css_class":null,"created_utc":1167476225,"score":1,"ups":1,"body":"In Haskell there is no concept of \"do x followed by y\", so it has been re-invented as \"monads\".  A monad describes the rules by which the side effects of \"x\" are seen by \"y\".  Different monads have different rules.\r\n\r\nMost programming languages work in what Haskell calls the \"IO\" monad: sequential execution, mutable state, no back-tracking or undo feature.  However Prolog works in a wierd hybrid monad.  It starts out with a back-tracking monad with unification, which is fairly straightforward.  But then it adds impure predicates for IO and database manipulation which have a lasting effect even if the computation they are in backtracks later.  This wierd mixture is what makes Prolog difficult.  As long as you stick to computations in its pure back-tracking monad then its great.  But as soon as you start on the impure stuff its impossible because the two paradigms keep fighting each other.\r\n\r\nSo I would recommend switching to Haskell.  You can have a backtracking monad in Haskell, simulate the unification yourself (I don't *think* there is any way to do that bit directly), and in the meantime use the IO monad to do the input and output.  The type system stops you mixing them inadvertantly.\r\n\r\nPaul.","controversiality":0,"link_id":"t3_wg30","stickied":false,"subreddit_id":"t5_2fwo","gilded":0,"retrieved_on":1473809673,"distinguished":null,"author_flair_text":null,"author":"paulajohnson","id":"cwg72","edited":false,"parent_id":"t3_wg30","timestamp_epoch":1566236780,"message_id":"58508-7b0e93e9-c3c8-4b7a-9f8e-6927742e553c-1566236780"}
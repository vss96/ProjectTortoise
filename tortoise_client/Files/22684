{"edited":false,"parent_id":"t1_cu1e1","id":"cu37c","author_flair_text":null,"author":"xcbsmith","distinguished":null,"retrieved_on":1473808063,"gilded":0,"subreddit_id":"t5_2fwo","stickied":false,"link_id":"t3_u0r5","controversiality":0,"body":"&gt; Subclassing \"Integer\" into \"Money\". Yeah, I'm not sure where to start with that one. I think I'll start by subclassing \"String\" to \"English\". That'll help me internationalize, won't it! And it's more domain-specific!\r\n\r\nHe'd didn't suggest subclassing. He suggested creating a distinct type for money. The classic Smalltalk implementations of Money classes don't extend Integer but rather contain an Integer, which makes a lot more sense when you think about it.\r\n\r\nMoney has a lot of properties that don't apply to Integers, and vice-versa. Martin Fowler has a lot of first hand experience with this and has written extensively on this subject. Check it out sometime, it'll help you write better code.\r\n\r\n&gt; The alternative to tag-and-switch programming is object hierarchies bristling with little leaf classes, each 20 lines of boilerplate and 4 lines of logic. Good job there! The acid test for tag-and-switch vs. polymorphism is how many times you have to do the tag-and-switch; if it's \"once\", you use the switch statement.\r\n\r\nWhere to begin... with that one. ;-) I do think people do tend to have an overly negative attitude about switch, particularly for languages which have a well formed switch (not C/C++). That said, if what you're switching on is really a type rather than some value, you really, really should be using polymorphism. It just ends up saving you trouble in the long run. Using an acid test like \"how many times do you have to do the tag-and-switch\" is silly, because the answer should always start with \"one\", but there's an incredibly high probability that this will change over time. Sometimes you use polymorphism, sometimes you use tag-and-switch, and sometimes you use a dictionary/map/associative array/array. They all have their place, but it's got a lot more to do with what the code is doing than \"how many times am I using it\".\r\n\r\n&gt; Anybody who says \"error codes are dead\" clearly also thinks C/ObjC/C++ is also \"dead\". Systems programmers can't rely on exceptions; they leave the program in undefined state.\r\n\r\n\"Error codes are dead\" is more along the lines of \"if it's really an error, don't just return some magic number\". Status codes make tons of sense. If you have a real honest to god error in C/ObjC/C++ you are generally better off firing off a signal, calling abort() (really the same thing as firing off a signal), triggering structured exception handling, using setjmp()/longjmp(), trigger an interrupt, etc.\r\n\r\nA proper exception-safe implementation should not result in exceptions putting a program in an undefined state. Of course, if you screw it up you can create quite a mess, but the same thing is true with return codes.\r\n\r\n&gt; Anybody who says end-of-block comments are \"beyond ignorant\" has never written a state machine before.\r\n\r\nI've written several state machines before, and frankly I can't even begin to imagine what your state machine code must look like if you need end-of-block comments. You define states with their transitions, conditions, actions, etc., then you have some code that wires them up. If you do it right, you shouldn't have any blocks huge enough to justify a block comment.\r\n\r\n&gt; Same with anyone who \"factors\" a coherent 1000-line method into a forest of pretty little methods.\r\n\r\nI'm impressed that you were able to use \"coherent\" and \"1000-line method\" together. ;-) If you have 1000 lines of \"coherent\" code, there ought to be several parts that are either stateless or whose state can easily be isolated from the rest of the code. If you don't, then your 1000 line method has enough state to be an object in its own right, and once you do that you'll find it much cleaner to then break things down in to simpler methods. 1000 lines is just too much code to have a clear idea of what the heck is going on, and it ends up being far too tricky to see the forest for the trees when it comes time to change the code.\r\n\r\n&gt; Have any of you noticed that many of the most ass-kicking programs out there aren't written in sexy languages, and aren't written to vanity \"code standards\"?\r\n\r\nI don't know who would be sadder, a coder focused on writing \"ass-kicking programs\" or a one focused on writing in \"sexy languages\". Write clean, tight code that gets the job done as well as possible with minimal effort. Worry about being \"sexy\" or \"ass-kicking\" some other time when it won't get you in to trouble.\r\n\r\nI'm not even sure what a \"vanity code standard\" is, but the article isn't talking about such a thing. I'm not sure if this is a complaint about the article as a whole or the section on style. As far as the article as a whole, there is little to do with vanity here. These are brain dead obvious things (if you've made the mistake before) that come back to haunt everyone later, and he's just venting about them. As far as the style point goes... all he wants is consistency, which doesn't seem like a vain request to me.","score":8,"ups":8,"created_utc":1165565541,"author_flair_css_class":null,"subreddit":"programming","timestamp_epoch":1566236763,"message_id":"15589-eb871ac1-f86f-4856-9603-91f0babe2ab2-1566236763"}
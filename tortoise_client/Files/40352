{"parent_id":"t1_cwaud","id":"cwb0z","edited":false,"author":"ricercar","author_flair_text":null,"distinguished":null,"retrieved_on":1473809577,"gilded":0,"subreddit_id":"t5_2fwo","link_id":"t3_w79v","stickied":false,"controversiality":0,"body":"\"State\" is just a convenient concept for describing the set of parameters to a function.  In imperative languages, that \"state\" is spread willy-nilly all around the program, and the history of the state has to be explicitly maintained.  In a functional language, it is well specified.\r\n\r\nThe counterpart to this statement, is that you can't just add new \"state\" without making it part of the function specification.  My reasoning is that, in the end, this will turn out to be better for you and the program.  In my case, I have received tangible benefits from maintaining discipline.  Naturally, I can't generalize that to everyone.\r\n\r\nI'm still learning Haskell as I proceed.  Rapid prototyping in Haskell is still an open question for me.  I benefit from past experience in this particular domain with this project, and with FP in general.\r\n\r\n&gt; Look at 'filter :: (a -&gt; Bool) -&gt; b a -&gt; b a' function \r\n&gt; and tell me how to simply lift it to a monadic form.\r\n\r\nI use `mapM` and `foldM` regularly.  Have you seen `filterM` btw?\r\n\r\n&gt; Allow mutation like in Ocaml. \r\n\r\nOCaml's mutation simply won't work well in this situation.  It's one of the things that turns me off the language, actually.  It depends on strict evaluation for one thing.  And it still causes me to lose the nice properties that I outlined (OCaml users don't care much for parallelism afaik, anyhow).\r\n","score":1,"ups":1,"author_flair_css_class":null,"created_utc":1167350547,"subreddit":"programming","timestamp_epoch":1566236779,"message_id":"55870-c4815a00-dbba-4cab-bd54-dcc5cb4c12d7-1566236779"}
{"author":"pjdelport","author_flair_text":null,"id":"cupvl","parent_id":"t1_cupsi","edited":false,"gilded":0,"retrieved_on":1473808489,"distinguished":null,"controversiality":0,"body":"&gt; I think you need more than laziness to state that - you need to ban sideeffects too.\r\n\r\nYou don't need to ban side-effects, you support them as first-class entities:  monads.  (As a side benefit, this gives you the power to define things like first-class continuations, exception handling, logic programming, automatic backtracking [and so on](http://programming.reddit.com/info/ox6s/comments/coxoh) purely as libraries too.)\r\n\r\n&gt; That aside, I would surprise me, if Haskell implementors compile \"ifs\" by rewriting it to function application first, and then compiling the result.\r\n\r\nHaskell doesn't need to rewrite it to function application because it already *is* just function application, for all intents and purposes.\r\n\r\nLooking at it from a different perspective, the very concept of imperative control structures depends on there *being* an implicit thread of execution to control in the first place;  however, there is no such thing in lazy (call-by-need) languages.\r\n\r\nIt's quite a different worldview.  :)","link_id":"t3_ujj3","stickied":false,"subreddit_id":"t5_2fwo","subreddit":"programming","author_flair_css_class":null,"created_utc":1166062100,"score":1,"ups":1,"timestamp_epoch":1566236768,"message_id":"27252-4dd3c27d-a8ab-4f82-9af8-e55a14e2b836-1566236768"}
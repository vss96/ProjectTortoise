{"author_flair_text":null,"author":"dons","id":"cw7hz","edited":false,"parent_id":"t3_w79v","gilded":0,"retrieved_on":1473809510,"distinguished":null,"body":"Some comments. Firstly:\r\n\r\n&gt; In most language you can simply write to some logging-stream to see what your program has done. This is often even more useful than using a debugger, because you can examine the history of the program execution and see what lead to a certain error. But in Haskell you need access to the IO monad\r\n\r\nNote that for tracing you can just use the pure [Debug.Trace](http://haskell.org/ghc/docs/latest/html/libraries/base/Debug-Trace.html) function.\r\n\r\nRegarding the need for state: if you're in the IO monad anyway, you can happily create true mutable global variables, which if time is short might be easier than switching to StateT. A true (and we may as well make it threadsafe) global is created thusly:\r\n\r\n    state = unsafePerformIO newEmptyMVar\r\n\r\nlater on you can get and set this value:\r\n\r\n    putMVar state \"some state\"\r\n    v â‰º- takeMVar state\r\n\r\nwhich you can now access in IO, as a global mutable bit of state. Sometimes I employ this trick when in a hurry.\r\n\r\n\r\nRegarding the pain of discovering later you need a monad, when you didn't plan for it: this seems to be an occasional gotcha for people coming from an imperative background.\r\nI think experiences with monadic programming, and Haskell in general, should help here, as you'll just code the more Haskellish pure solution, rather than decide on the need for an IORef or some other mutable state.\r\n\r\nI find I don't tend to code myself into a monadic box/rewrite ever these days, though it happened once or twice when I was starting out. More experience in Haskell program design should help.\r\n\r\nIt's a bit disappointing that the monadic refactor issue is considered a show stopper. My experience has been that once you understand precisely how you can employ a monad, and what they're good for, costly refactoring just doesn't occur.\r\n\r\nI wonder if more advice and guidlines for transitioning from heavy update/state-based programming to less-stateful, more referentially transparent functional programming might be useful for those making the leap.","controversiality":0,"link_id":"t3_w79v","stickied":false,"subreddit_id":"t5_2fwo","subreddit":"programming","author_flair_css_class":null,"created_utc":1167270705,"score":30,"ups":30,"timestamp_epoch":1566236779,"message_id":"54133-150ed911-14f3-44b6-bae4-a05d32d689fa-1566236779"}
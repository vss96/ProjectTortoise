{"distinguished":null,"retrieved_on":1473809232,"gilded":0,"edited":false,"id":"cvsws","parent_id":"t1_cvs04","author":"beowulf","author_flair_text":null,"score":10,"ups":10,"created_utc":1166834614,"author_flair_css_class":null,"subreddit":"programming","subreddit_id":"t5_2fwo","stickied":false,"link_id":"t3_vr55","controversiality":0,"body":"As I said earlier, the primary problems when building large systems are not related to type checking issues.  Going off my memory of the bugs we dealt with I only remember two errors that were type checking issues (ie, someone passed an array and the method expected a single value or someone typo'd a property on an object in Python or something equally simple).  The vast majority of errors or problems were sloppy logic, poor database design or interaction, or lack of understanding of run time performance.  I've seen sloppy and buggy logic built in every language I've ever used.  Although in all honesty I saw significantly more runtime logic errors in C# than I did in Python or Ruby.  \r\n\r\nMy theory goes something like this.  In C# you really have to fight the type system all the time, just getting something to compile can sometimes be a minor miracle.  So I've seen dozens of C# programmers actually stamp a program as done simply because they got the thing to compile.  Where in Python or Ruby things almost always compile, unless there are obvious semantic errors, so then you have to start looking at whether or not your program is actually doing what it should be doing.\r\n\r\nSo my thoughts are that static typing leads people into a false sense of security thinking that just because it compiles it's free of errors, or even mostly free of errors.  That's just flat not the case with most complex systems.\r\n\r\nNext it's much more difficult to do \"good\" abstraction in C# compared to Python or Ruby.  The difficulty with doing good abstraction and the general wordiness of the language tends to produce programs that are much longer to do the same thing.  I know \"good\" is a loaded term, but it's based of my own personal experience using static versus compiled languages.  YMMV.\r\n\r\nThe gist of my post wasn't meant as a bash at C#.  I think there is a time and a place for C# and Java.  They are significantly faster computationally than Python or Ruby, but they also require significantly longer programs to solve the same problem.  In my opinion it's important to know the tradeoffs you are making when you choose a specific language.  I don't think there is a cureall language yet that is both fast, compact and safe.  I know people think Haskell might be it, but I have my doubts about that.\r\n\r\nAnyway, as I stated above, the real issues on big systems have to do with much harder to tackle problems than static type checking versus dynamic type checking.  Unfortunately those issues are much more difficult to solve, but that's probably why people don't debate them as much.","timestamp_epoch":1566236775,"message_id":"46543-7b4750fa-1f24-4acb-a848-8dd9dc741da1-1566236775"}
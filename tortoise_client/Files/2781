{"controversiality":0,"body":"The [reference](http://www.progsoc.uts.edu.au/~sbg/intercal/intercal.html) is not that horrible.\r\n\r\nYou can stash away variables multiple times and retrieve them in a stack-like fashion, you have a nice instruction stack, an optimization instruction to chop the instruction stack when you don't intend to return; you can freeze and unfreeze variables a-la Ruby.\r\n\r\nAlthough there is no IF, and the argument to DO (linenumber) NEXT can only be a constant, you have DO RESUME x, where x can be a variable, thus branching is possible.\r\n\r\nPrinting output is rather limited to \"enhanced\" Roman numerals, but you can force custom output by a deliberate compiler error, which will not be fatal during compilation and will be output during execution.\r\n\r\nI'm still not sure how it is Turing complete given it can have a maximum of 65535 labels - surely there are problems that require more?\r\n\r\nIf I were stuck with an Intercal machine in heaven or hell where time has no meaning, I'd implement a simple register-based machine, write an assembler for it, then a C compiler, and take it from there :)\r\n\r\n(this is all tongue in cheek)","stickied":false,"link_id":"t3_w96b","subreddit_id":"t5_2fwo","subreddit":"programming","created_utc":1167360958,"author_flair_css_class":null,"score":5,"ups":5,"author_flair_text":null,"author":"[deleted]","parent_id":"t3_w96b","edited":false,"id":"cwbi8","gilded":0,"retrieved_on":1473809585,"distinguished":null,"timestamp_epoch":1566236779,"message_id":"56127-31a16caf-851e-48bf-bfee-425cf9c0b0fd-1566236779"}
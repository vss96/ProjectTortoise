{"author":"sidecut","author_flair_text":null,"parent_id":"t3_ubc0","id":"cuc94","edited":false,"gilded":0,"distinguished":null,"retrieved_on":1473808233,"controversiality":0,"body":"Correct me if I'm wrong, but there *is* a big difference between lambda functions and inline functions.  They're apples and oranges, although I suppose they do have similarities.\r\n\r\nAn inline function, at least in C/C++, is similar to a C-style macro -- it's code that is emitted everywhere it is used, without a jump-to-subroutine instruction, without pushing function arguments onto the stack, and without a return instruction.  It's a programmer-chosen optimization that chooses execution speed by sacrificing memory often used for functions whose implementation is trivial.  In the compiled code, a copy of the function is made everywhere the function is called, in contrast to a normal function, where there is exactly one copy of the body of the function.  (Note that optimizing compilers can futz with this.  I'm talking about programmer intent, and traditional implementation without advanced compiler optimization.) \r\n\r\nA lambda function, on the other hand, has nothing to do with inlining.  Indeed, it is probably compiled the way a normal function is, that is, with there being exactly one copy of the compiled code, with a call/return and parameters passed on the stack.\r\n\r\nBecause of the author's confusion on this issue, I stopped reading after the first two paragraphs.  I think the article should be taken as \"here is my personal experience experimenting with lambda functions\" instead of being an authoritative explication of the concepts.","subreddit_id":"t5_2fwo","link_id":"t3_ubc0","stickied":false,"subreddit":"programming","score":1,"ups":1,"author_flair_css_class":null,"created_utc":1165773195,"timestamp_epoch":1566236765,"message_id":"20378-65fb73ab-5d64-4975-a9dd-5318deed7c0e-1566236765"}
{"author":"ayrnieu","author_flair_text":null,"parent_id":"t3_vzw8","edited":false,"id":"cw16e","gilded":0,"distinguished":null,"retrieved_on":1473809390,"controversiality":0,"body":"Erlang and Perl.  But I feel that I'd communicate better if I explained why I don't hold some of these other languages as my language of choice:\r\n\r\nNot python. Although someone calls it elegant and maintainable in this thread, and people often declare that they have an easy time reading it, I hold little faith for any of these attributes.  For inelegance, Python offers explicit returns, a destructive *array sort* among its crimes against functional programming, bizarre scoping, a pointlessly limited lambda, and disk-cached bytecode that never seems to help with anything.  For unmaintainability and unreadability, Python has the result of its cultural and linguistic biases: huge, undifferentiatable swaths of code, indented to the horizontal stratosphere, offering the bewildered eye on every *line* a singularly clear statement of code that helps to form an inpenetrable *block* of code -- and all of it massaged, with referential transparency or clear interaction completely out the window, into idiotically-named objects in a chaotic, undocumented heirarchy.  I've hacked on Python programs, but you can dive in, make a change, and flee from any codebase: Python on whole only stands in the way of a maintainer trying to understand a codebase.\r\n\r\nNot ruby. I *used* to like Ruby -- back when matz still wrote the English documentation and it had the primary hypes of 'Look at how reflective and pretty it is!' and the primary criticism of 'I cannot accept that it has so many ends!'.  I thought then that it might be a 'better Perl' -- but since then, Perl has itself turned into 'better Perl', and Ruby has improved only in that it now has jobs.\r\n\r\nNot Ruby or Python: they have manners of development identical to Perl.  They have plusses and contrasts-to-other-languages identical to Perl's.  Their communities fall ill to memes largely identically to Perl's.  They are effectively one language, with a winner-takes-all relationship as far as devotees go.  For me, Perl won.  I can go back and learn the new tricks Python has come up with -- and probably will, when I need to deal with a nifty python program, but this would otherwise only waste time that I could better spend on constantly-there languages -- and on novel languages.\r\n\r\nNot Haskell.  'Haskell' effectively means 'GHC', and the last release of GHC had (cout'em:) three supported platforms.  Ah, great, you can upgrade with an older GHC -- so however many few platforms in addition that this comes to.  Ah, even better, you can take GHC on one platform and cross-compile to another platform, somehow, producing C code that you can then massage, somehow, and then compile on that another platform.  No, until the Haskell community gets serious about portability, I for the most part *simply can't* use it.  When I have used it, it has competed with better-documented, vastly more-portable, plainly better-engineered O'Caml.\r\n\r\nNot Factor.  See complaints about GHC.\r\n\r\nNot D.  I don't care about C++, better C++'s, or any manner of not-very-different better-than-Cs.  C itself I care about only insofar as I find that many interesting programs use it, that C programs themselves always seem to come packaged with sincere efforts to make them portable throughout unix, that having languages that can hook into C allows me to interact in very interesting ways with aforementioned interesting C programs.  C is a useful, but not a great language, and nothing that tries to position itself as a superset (of a superset...) of C can interest me very much.\r\n\r\nSpeaking of which, not C++.  Or C#.\r\n\r\nNot Java.  I don't want to touch a language so fearsome that it has spawned its own industry of code-mucking tools.  Even if I did: no Java program interests me very much, and see my complaints about GHC.\r\n\r\nNot PHP.  Nobody who has put effort into any of Perl, Python, or Ruby can have anything but little-adulterated contempt for this hackish, obscene ball of mud.  From core to extensions to community to documentation to popular programs -- *burn it all*.  Even someone not so immunized against this language should be able follow http://tnx.nl/php\r\n\r\nNot APL.  See complaints about GHC, and then pretend furthermore that GHC is a closed-source program purveyed by people who won't even list a price.\r\n\r\nNot BASIC.  But the person suggested that as a joke, I guess.\r\n\r\nNot any kind of Pascal.  By negative bias from two imperfect sources: http://www.lysator.liu.se/c/bwk-on-pascal.html and the footnote on this page http://www.ugcs.caltech.edu/manuals/lang/gforth-0.6.2/Structure-Usage.html\r\n\r\nNot Objective C.  See complaints about D.\r\n\r\nNot assembly.  Because I know Forth.\r\n\r\nNot JavaScript.  I like it, and it amuses me that it's the only programming language you can rely on in the world of desolate microsoft systems -- but it seems that I only ever use it to dumbly polish what I generate with Perl.  If I didn't need to generate even the most basic data for JavaScript, due to its lack of multiline string literals or HERE docs, maybe then I could care enough to do some moderately actual work with it.\r\n\r\nNot JScript.  Oh, you meant this instead of JavaScript?  I have nothing to do with windows programming, so: no need.  If someone threatened assault unless I produce a win32 program, I'd probably use Erlang or REBOL.  Or Emacs -- hah!\r\n\r\nNot nude celebrities.  These are poorly composable, worse even than assembly in getting something done.  I can't even fathom why you'd choose it.\r\n\r\nNot like that.  Please do it this way: `sub perl_does_not_care { shift + 1 }`\r\n\r\nFinally, two small notes about my languages of choice.  Perl has unmatched wealths in CPAN, in its electronic documentation and its written books, in the expertise and charitableness of its commmunity, and simply in its growth and history: it has over time developed features and worn away deficiencies in a manner far and away above that of any language in any context.\r\n\r\nOf Erlang, I'll say: it does not offer simply lots of processes, nor even just asynchronous concurrency with message-passing, nor only hot-code loading and multiple versions of modules; it is merely supremely good at processes, or distributed fault-tolerant soft-real-time systems; it is not merely good at telephony applications.  I can't explain the depth of solid, cohesive engineering in Erlang that makes me roll my eyes when someone posits that e.g., Python has some of these features.  I used Erlang for quite a while before I discovered the sweet-spot of hacking with it, where classic cycles (edit-&gt;run-&gt;debug) of programming fold away and I'm left with something almost absurdly fast and responsive, that nobody has given me a cutely hyped term for.\r\n\r\nThat's all.  Some derisiveness and some bitterness and some praise undifferentiable from religion.  You probably wanted more flame than you've gotten, so far.\r\n","subreddit_id":"t5_2fwo","link_id":"t3_vzw8","stickied":false,"subreddit":"programming","score":13,"ups":13,"author_flair_css_class":null,"created_utc":1167111291,"timestamp_epoch":1566236778,"message_id":"50705-b04f380b-fc46-48b9-aa67-8b7f84867c03-1566236778"}
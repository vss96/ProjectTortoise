{"link_id":"t3_w79v","stickied":false,"subreddit_id":"t5_2fwo","controversiality":0,"body":"Generally speaking, wanting to insert some kind of \"mutation\" into your code is a sign of leftover imperative thinking.  Referential transparency is important in keeping your code simple and the bugs out.  You don't have to worry about unintended changes creeping into other code; a problem which is endemic in imperative languages like Java and Python.\r\n\r\nFactor your code into simple functions as is best practice, and you'll find that adding new functionality is pretty easy.\r\n\r\nFor example, I have a tree structure in which I would like to prune some links.  But if I were to \"directly\" do that, it would screw everything up; I share the tree between multiple threads which perform various computations on it.\r\n\r\nNow I am spending some time thinking about how I want to fit this new idea into the overall architecture, and the consequences of where I put it.  It's not going to be difficult to implement whatever I do, because there just isn't that much code which needs to be changed.  And the static type system will make sure I don't forget any spot, either.\r\n\r\nYou find that in Haskell, you spend more time thinking than coding.  This could turn out to be \"wasted\" thinking, but that doesn't generally turn out to be the case.  I'd say it's because of referential transparency, which makes code easy to reason about (formally, or informally).\r\n","author_flair_css_class":null,"created_utc":1167332877,"ups":4,"score":4,"subreddit":"programming","parent_id":"t3_w79v","id":"cw9zs","edited":false,"author_flair_text":null,"author":"ricercar","retrieved_on":1473809557,"distinguished":null,"gilded":0,"timestamp_epoch":1566236779,"message_id":"55329-cb36e389-eb61-4c8b-942e-7fd6ed4cf17f-1566236779"}
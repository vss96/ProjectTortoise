{"link_id":"t3_uuzg","stickied":false,"subreddit_id":"t5_2fwo","body":"There are a lot of good comments here, but I haven't seen someone take a really harsh, brutal devil's advocate crack at dons' thesis.  So let me have a go.\r\n\r\nShould source in a good programming language look like pseudocode?\r\n\r\nThe obvious answer is \"yes.\"  As all and sundry have pointed out, a language is a UI for programmers.  Programmers choose pseudocode syntax for its power to express concepts clearly and readably.  Obviously the same goals are crucial for true code.  Thus, a programming language should strive to look as much as possible like pseudocode.\r\n\r\nBut there is a less obvious answer, which is \"no.\"  I think this \"no\" goes some way toward explaining why Haskell, despite its obvious superiority on many counts, is still so little used.\r\n\r\nThe goal of pseudocode is to be *readable*.  Since pseudocode is not executed, the difficulty of *writing* precise and correct code doesn't really enter into it.  All it has to do is get the point across.\r\n\r\nIn other words, pseudocode syntax is optimized to *look elegant*.  Since the designers of Haskell seem to have pretty much shared dons' perspective, we can make a tentative assumption that their goals were similar.  And in fact, Haskell code looks and has always looked quite elegant to me.\r\n\r\nThe problem is that when you try to write a spec for syntax that looks elegant, you get paragraphs like this:\r\n\r\n&gt; Informally stated, the braces and semicolons are inserted as follows. The layout (or \"off-side\") rule takes effect whenever the open brace is omitted after the keyword where, let, do, or of. When this happens, the indentation of the next lexeme (whether or not on a new line) is remembered and the omitted open brace is inserted (the whitespace preceding the lexeme may include comments). For each subsequent line, if it contains only whitespace or is indented more, then the previous item is continued (nothing is inserted); if it is indented the same amount, then a new item begins (a semicolon is inserted); and if it is indented less, then the layout list ends (a close brace is inserted). If the indentation of the non-brace lexeme immediately following a where, let, do or of is less than or equal to the current indentation level, then instead of starting a layout, an empty list \"{}\" is inserted, and layout processing occurs for the current level (i.e. insert a semicolon or close brace). A close brace is also inserted whenever the syntactic category containing the layout list ends; that is, if an illegal lexeme is encountered at a point where a close brace would be legal, a close brace is inserted. The layout rule matches only those open braces that it has inserted; an explicit open brace must be matched by an explicit close brace. Within these explicit open braces, no layout processing is performed for constructs outside the braces, even if a line is indented to the left of an earlier implicit open brace.\r\n\r\nThis - from the [Haskell Report](http://www.haskell.org/onlinereport/) - is the *informal* definition of Haskell layout.  If anyone feels undaunted by this, they can check out the [formal definition](http://www.haskell.org/onlinereport/syntax-iso.html#layout).  (Of course, the word \"formal\" should be in quotes, because Haskell is not actually formally defined.)\r\n\r\nA language, indeed, is a UI for programmers.  In the world of commercial and open source design, 90% of UI design is making your product easy to learn, because your goal as a producer of software is to have customers.  This may not make for the absolute optimal result for power users, but that's too bad.\r\n\r\nIn the world of CS research that Haskell comes from, software is a byproduct.  The real product is publications and careers.  Haskell developers would *love*, *love*, *love* to have more users, but they are generally people with research careers and they *need* publications.\r\n\r\nSo it makes a great deal of sense for them to produce a language that looks very beautiful on the printed page, but is very hard to learn.  \r\n\r\nNotice the way that you are supposed to learn Haskell.  It is always some kind of a tutorial.  Tutorials are a great way to get your feet wet in a language, but many programmers, especially the smart people who are anyone's initial usert base, respond better to what is simply a well-annotated spec.  Look at K&amp;R, for example - probably the most successful language book of all time.  It starts with a quick tutorial and then simply explains the language features.  \r\n\r\nI suspect it would be very difficult to produce a K&amp;R style book for Haskell.  What I see when I look at Haskell is some extremely smart people (like dons) who are Haskell wizards and could probably reel off that layout definition in a minute without even thinking, a larger number of very smart people who have learned to program effectively in Haskell and know most of its features, and an even larger number of just plain smart people who have worked through a bunch of tutorials, but still fix their type inference errors by binary search.\r\n\r\nThis is not, in my opinion, success.  Here is my prediction for the future of functional programming: FP is the future of programming, but it will take off only when someone designs a functional language that anyone with an IQ over 110 can learn in a few days just by reading the spec.\r\n\r\nWhy should functional languages be so much more difficult to learn than imperative ones?  After all, functional programming is simply imperative programming minus side effects.  This should be easier, not harder.  \r\n\r\nAgain, I suspect the problem has more to do with the research ethos that created the functional languages we have.  If this is true, the world is still waiting for someone to be the van Rossum, Torvalds, Wall or Matz of FP.","controversiality":0,"author_flair_css_class":null,"created_utc":1166205438,"score":8,"ups":8,"subreddit":"programming","edited":false,"parent_id":"t3_uuzg","id":"cuxqb","author_flair_text":null,"author":"[deleted]","retrieved_on":1473808636,"distinguished":null,"gilded":0,"timestamp_epoch":1566236769,"message_id":"30948-b1e0a745-8255-4eb0-bacd-2daa00079752-1566236769"}
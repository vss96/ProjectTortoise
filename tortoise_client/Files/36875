{"gilded":0,"distinguished":null,"retrieved_on":1473808772,"author":"julesjacobs","author_flair_text":null,"id":"cv4vd","edited":false,"parent_id":"t1_cv4dx","subreddit":"programming","score":7,"ups":7,"created_utc":1166384873,"author_flair_css_class":null,"controversiality":0,"body":"I think this is what he says in OO terms:\r\n\r\nA Map lookup can fail because there is no value associated with a key. Some languages throw you an IndexError, others return nil. \r\n\r\nHaskell uses a Maybe. `Maybe` is an implementation of a  `Monad`. It's like OOP: Monad is the superclass and Maybe is the child. Monads support various functions (methods). Two interesting functions are `return` and `fail`. All monads support these functions. Monads are like an interface: they state which methods the deriving classes have to implement.\r\n\r\nThe map lookup function uses the `return` function if the key is present in the map and `fail` otherwise. Now you can give the lookup function a type that says that it uses the Maybe monad, or you can give it a more general type that allows all monads (this is possible because they all support return and fail). You will probably use the Maybe monad to handle lookup errors, but in some cases it's handy to use another monad. Therefore it's good to use a general type that allows all monads to be used.\r\n\r\n    fail msg = Nothing\r\n\r\nmeans that if you call `fail` in the Maybe monad you'll get Nothing (a value like NULL or nil).\r\n\r\n    fail msg = []\r\n\r\nmeans that you get an empty list if you call fail in the List monad.\r\n\r\n    fail msg = error msg\r\n\r\nmeans that you get an error message (printed to the console) if you call fail in the IO monad.","subreddit_id":"t5_2fwo","stickied":false,"link_id":"t3_v34f","timestamp_epoch":1566236771,"message_id":"34320-33d0d63b-13f8-4aa5-9edc-4e4860abb3bb-1566236771"}
{"subreddit":"programming","created_utc":1166161650,"author_flair_css_class":null,"score":1,"ups":1,"controversiality":0,"body":"&gt; I believe your statement \"With lazy evaluation, all control structures degenerate into pure function application.\" is untrue for a lazy language with side effects.\r\n\r\nNo, it's equally true with or without side-effects.  The side-effecting lazy function call `if x (print \"yes\") (print \"no\")` will print either `yes` or `no`, depending on which of the last two parameters it \"returns\".  Same for sequencing and other control structures:  functional dependency enforces the evaluation order.\r\n\r\n(This is pretty much how Haskell actually handles I/O and other side effects, by the way;  for more details, see the excellent [IO inside](http://haskell.org/haskellwiki/IO_inside) tutorial.  (You don't need to know too much Haskell to follow it.))\r\n\r\n&gt; That a program with side effects can be rewritten into monad form (which can be run in a pure language) is irrelevant (interesting, but irrelevant).\r\n\r\nRight;  monads are a helper library.  They expand into nothing but plain, lazily-evaluated functions (both side-effecting ones and not).  You can manually write exactly the same code without them, if you really wanted to.","stickied":false,"link_id":"t3_ujj3","subreddit_id":"t5_2fwo","gilded":0,"retrieved_on":1473808588,"distinguished":null,"author_flair_text":null,"author":"pjdelport","id":"cuv5y","parent_id":"t1_cutqy","edited":false,"timestamp_epoch":1566236769,"message_id":"29841-f192a904-0df8-458f-b769-399da89b7d12-1566236769"}
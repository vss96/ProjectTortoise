{"subreddit":"programming","score":2,"ups":2,"created_utc":1166968062,"author_flair_css_class":null,"body":"*part 2*\r\n\r\nHow do these features enhance readability and therefore expressiveness? Pattern-matching is easy — just compare the following snippets:\r\n\r\nErlang:\r\n\r\n    foo({bar, [baz, boing], \"18\"}) -&gt; ok;\r\n    foo(_) -&gt; error.\r\n\r\nImperative, dynamic pseudo-language:\r\n\r\n    foo(arr) {\r\n      if (arr instanceof Array &amp;&amp;\r\n           arr.length == 3 &amp;&amp;\r\n           arr[0] == 'bar' &amp;&amp;\r\n           arr[1] instanceof List &amp;&amp;\r\n           arr[1].size() == 2 &amp;&amp;\r\n           arr[1].element(0) == 'baz' &amp;&amp;\r\n           arr[1].element(1) == 'boing') &amp;&amp;\r\n           arr[2] instanceof String &amp;&amp;\r\n           arr[2].equals(\"18\"))\r\n        return 'ok';\r\n      else\r\n        return 'error';\r\n    }\r\n\r\n**Update (12/12/06)**: If you read Anders’ comment, you’ll see that code such as above can be written more succinctly in Python. Please take this example as an illustration of how Erlang pattern matching engine works rather than as a suggestion that there’s no better way of writing such code in any imperative language.\r\n\r\nI hope this example makes the benefits of pattern-matching obvious :) So, let’s look single-assignment, which is another functional programming feature that I have learned to appreciate as an essential contributor to code quality. In Erlang, when you bind a value to a variable, this binding holds for the life of the variable. For instance, in Erlang, if you wrote code such as\r\n\r\n    foo() -&gt;\r\n      X = 1,\r\n      X = 2.\r\n\r\nthe second expression would throw an error. If you’re used to Erlang, the reason is quite natural: the first line states that X equals 1, and therefore the following line, stating that X equals 2, is wrong. To someone who isn’t used to functional programming, the benefits of this behavior may not be obvious — it may even seem like a burdensome restriction (I used to think so too). However, over time I learned that single-assignment often makes for drastically more readable code. For example, consider this snippet in an imperative/OO/dynamic language:\r\n\r\n    out(name, paradigm) {\r\n    var l = new Language(name, paradigm);\r\n\r\n    // much code below\r\n    …\r\n    l = bar(l);\r\n\r\n    // much code below\r\n    …\r\n    return l.getName() + “/” + l.getParadigm();\r\n    }\r\n\r\nNow answer the following question: what does ‘out(”Ruby”, “imperative”)’ return? Clearly, you have no way of knowing. In fact, even reading the all the code for the ‘foo’ function won’t help you much — you’d have to read the code for ‘bar’ (and any other function that take ‘l’ as a parameter) in order to have a better clue. Sadly, all that reading still wouldn’t guarantee anything if the value of ‘l’ changes during execution based on some IO input. And that’s not the end of it: to make things worse, your life would be even much more miserable if the author of the code decided to venture into the dangerous terrain of multi-threaded programming. If ‘l’ is shared between different threads, your code comprehension efforts would be that much closer to hopeless.\r\n\r\nIf this code were written in Erlang, the answer would be simple: the function ‘foo’ returns a string of value “Ruby/imperative”. In small code snippets, such as the ones used in most language comparisons, the readability benefits of single-assignment may not be obvious. However, in a large-scale production systems with high availability requirements written by large teams of developers, the ability to answer questions about unfamiliar code segments is essential for both readability and (automated and non-automated) debugging. Erlang was designed to build such systems, so it makes sense that Erlang shuns mutable variables. (I imagine Ericsson would be in a rather uncomfortable position if a portion of England’s phone network went offline because some programmer thought to himself, “the variable ‘l’ holds an object of type ‘Language’!” :) )\r\n\r\nSo where does all this lead us? Is there a precise way of measuring language expressiveness that takes into account both conciseness and readability? Well, after thinking about this stuff for a while, I arrived at an elegant equation for arriving at an objective quantitative measure of a language’s expressiveness. Without further ado, here is my equation for the General Theory of Programming Language Expressiveness:\r\n\r\nE = C*R^2\r\n\r\nwhere\r\n\r\nE is expressiveness\r\n\r\nC is conciseness\r\n\r\nR is readability\r\n\r\nNow I just need to figure out how to factor in the speed of light. If I succeed, it would undoubtedly pave the way for the Nobel :)\r\n\r\nWell, I hope I was able to shed some light on why readability is at least as important as conciseness when evaluating language expressiveness, and also why code written in functional languages (primarily Erlang) enjoys greater readability — and often, conciseness — than code written in imperative/OO languages. Now consider this: even if imperative/OO languages were just as concise and readable as Erlang, Erlang code would nonetheless have a higher average quality. Sounds bizzare? Maybe, but it’s true :) The reason is that no matter how good a language is, bugs always creep into non-trivial systems, and Erlang is the only language I know that has truly effective mechanisms for dealing with defects that do affect live systems. The idea behind Erlang’s approach to fault-tolerance is actually quite simple: a crash in one process doesn’t bring down the whole system, and furthermore it’s detected by a supervising process that’s configured with rules telling it what action to take (e.g. restart the process) when a crash does occur. When you’ve fixed that pesky bug that has been causing intermittent (yet non-catastrophic!) crashes, you can hot swap the new code into the live system without taking if offline. Due to Erlang’s fault tolerant design, 1000 lines of Erlang code with 7 bugs are in a sense “better” than 1000 lines of Java doing exactly the same thing and containing an equal number of bugs. Unfortunately, comparisons that count only line numbers don’t show this side of the story.\r\n\r\nIf none of this convinces you that functional languages are worth using, maybe this tip the paradigm balance in your mind: I’ve never met a programmer who’s versed in both functional programming and OO/imperative programming and who prefers the latter.\r\n\r\nBut maybe I just need to get more friends :)","controversiality":0,"subreddit_id":"t5_2fwo","stickied":false,"link_id":"t3_uky3","gilded":0,"distinguished":null,"retrieved_on":1473809309,"author":"silly_coward","author_flair_text":null,"edited":false,"id":"cvwws","parent_id":"t1_cvww8","timestamp_epoch":1566236777,"message_id":"48466-1222c97a-e640-4e0f-91d2-f1336b059e6c-1566236777"}
{"controversiality":0,"body":"Firstly, those are just a few of what I thought were some of the best examples from my own experience.\r\n\r\nNote that I'm *not at all* saying \"redevelop ML\". In fact, that's almost exactly the opposite of what I'm saying. If you don't know Haskell, ML, Prolog, Smalltalk, etc. you're going to end up retracing their mistakes and successes. You're going to spend a lot of effort (Maybe 20 years by many many people) rediscovering not just the good stuff, but the mistakes along the way too.\r\n\r\nAs Don points out, these are languages which the PL design community have put a lot of work and research into. They're  major research languages of the last 20 years. The ideas that have been developed there are things which I think should be well known by every language designer. (If not by every programmer!) We see lots and lots of languages come out with features that only modestly extend 1970's and 1980's ideas, due to people not really understanding what's been done since then.\r\n\r\nYou're right that I am a Haskell fan. Haskell, Clean, Mercury, ML etc. are not perfect languages by any means, but they represent a major class of languages with a huge number of often-ignored ideas in them.\r\n\r\nThere are also *lots* of PL ideas which are not in Haskell, Scheme, Lisp, ML, etc. but are implemented as libraries in these languages.\r\n\r\nThere are ideas which are escaping now into other more mainstream languages, LINQ is largely inspired by functional programming techniques, for instance. (Erik Meijer used to work on Haskell.)\r\n\r\nHowever, there are too many languages which are caught up in this imperative rut, and not enough new languages which are unafraid to try more declarative approaches to things.\r\n\r\nIt's really important to move in that direction for a large number of reasons, not the least of which being that processor clock-speeds are no longer increasing as quickly as they used to, and we're going to start having to rely on parallelism. If your program semantics specify absolutely the order in which everything must occur, it becomes very hard to get decent performance gains from parallelism.\r\n\r\nThere are also just things which you see once you've been exposed to languages like these for long enough -- opportunities for factoring programs which apparently didn't occur to the designers of many other languages. I apologise for the slight tone of disdain, but there really are many things which could be improved in mainstream languages. There are many ideas that were being used in Scheme 20 years ago which still haven't completely made it to the mainstream. (Watch the [SICP lectures](http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/)!)\r\n\r\nIt's really a matter of getting people to the point where they're aware of what's been done and they're able to make informed design decisions between options which most people right now don't seem to even be able to see or consider.\r\n","stickied":false,"link_id":"t3_tif6","subreddit_id":"t5_2fwo","subreddit":"programming","created_utc":1165221796,"author_flair_css_class":null,"score":16,"ups":16,"author_flair_text":null,"author":"cgibbard","parent_id":"t1_ctixy","edited":false,"id":"ctj27","gilded":0,"retrieved_on":1473807689,"distinguished":null,"timestamp_epoch":1566236760,"message_id":"6213-bbc264d3-d9e3-4194-a340-08e81a29f7da-1566236760"}
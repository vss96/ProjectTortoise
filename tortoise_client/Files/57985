{"id":"ctiqj","parent_id":"t3_tif6","edited":false,"author_flair_text":null,"author":"schwarzwald","distinguished":null,"retrieved_on":1473807682,"gilded":0,"subreddit_id":"t5_2fwo","link_id":"t3_tif6","stickied":false,"controversiality":0,"body":"My particular domain of interest is tinkering with optimization metaheuristics and evolutionary computation, so I want these things:\r\n\r\n- Stupid-easy integration with C libraries. \r\n- Brief. I have a sweet tooth for syntactic sugar that can never be satisfied. I have a fever and the only prescription is more syntactic sugar.\r\n- ML-like. Strong, static, safe, with type inference.\r\n- Support functional programming but don't have a shit attack when I want to do a for loop because I want to isomorphically transcribe algorithms I find in books that assume you're coding in an Algol-like language.\r\n- Fast. Make vectorization very easy, make linear algebra operations first-class citizens which actually wind up using fast architecture-specific BLAS/LAPACK routines.\r\n- Loops parallel by default. Make it very easy to take advantage of multiple cores on embarassingly parallel computations. The compiler is supposed to help the programmer, not the other way around.\r\n- Lots of examples and good documentation.\r\n- Comes batteries included. Don't make me chase down 20 different libraries the way I have to with Scheme and Emacs.\r\n\r\nAbility to distribute native apps that don't require a large runtime footprint and/or native GUI controls (by native I mean really native, not half-assed and good enough for other programmers) would be nice but are not essential. The above are much more important.\r\n\r\nOCaml with a year of full-time work by 3 dedicated people could make this happen.","score":8,"ups":8,"author_flair_css_class":null,"created_utc":1165213640,"subreddit":"programming","timestamp_epoch":1566236760,"message_id":"6086-079076d6-1018-4cbf-bcea-9b8f290d6db5-1566236760"}
{"author_flair_text":null,"author":"pjdelport","id":"cupmi","edited":false,"parent_id":"t1_cuokv","gilded":0,"retrieved_on":1473808485,"distinguished":null,"controversiality":0,"body":"&gt; This is precisely the wart in lisp/scheme. Macros/special forms aren't first class in lisp/scheme.\r\n\r\nDepends.\r\n\r\nCommon Lisp's predecessors have long had first-class macros in the form of [FEXPR and NLAMBDA](http://www.nhplace.com/kent/Papers/Special-Forms.html), but they were dropped because their added flexibility didn't really justify their lack of efficient compilation.  (Apparently.  I don't know if any modern Common Lisp implementations still offer something similar as an extension to the standard.)\r\n\r\nSimilarly with Scheme:  R5RS doesn't include first-class macros, but several [Scheme](http://web.cs.wpi.edu/~jshutt/kernel.html) [dialects](http://code.google.com/p/muvee-symbolic-expressions/) and [R5RS implementations](http://okmij.org/ftp/Scheme/run-time-macros.txt) do.\r\n\r\n&gt; In a lazy language (such as Haskell), in some sense you can think of every function being a macro (i.e. something which is evaluated before it's arguments are).\r\n\r\nOnly a specific, limited kind of macro:  they can specify control flow, but not actually modify any program structure, the _raison d'Ãªtre_ of Lisp macros.  (This is why Template Haskell exists.)","stickied":false,"link_id":"t3_ujj3","subreddit_id":"t5_2fwo","subreddit":"programming","created_utc":1166055813,"author_flair_css_class":null,"score":6,"ups":6,"timestamp_epoch":1566236768,"message_id":"27138-5c0f3a4a-a28b-4b40-86f7-2ab2cf95ab1b-1566236768"}
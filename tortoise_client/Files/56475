{"author_flair_css_class":null,"created_utc":1166967446,"score":3,"ups":3,"subreddit":"programming","link_id":"t3_uky3","stickied":false,"subreddit_id":"t5_2fwo","controversiality":0,"body":"*posted here because the author unpublished the original*\r\n\r\nA General Theory of Programming Language Relativity\r\n===================================================\r\n\r\n*from Yariv's Blog by Yariv*\r\n\r\nI don’t usually write responses to other articles because, frankly, I think people spend too much time writing articles and too little time writing open source Erlang code that I can use without paying those do-gooder souls a dime for their efforts :) However, this one — [“No Silver Bullet” and Functional Programming][silver] — piqued my curiosity because it discusses functional programming in a positive light and it mentions Erlang a bunch of times. Clearly, the author has gotten \\*something\\* right :)\r\n\r\n[silver]: http://cogito.blogthing.com/2006/12/06/no-silver-bullet-and-functional-programming/\r\n\r\nI actually think the author did a pretty good job at explaining some of the benefits of functional programming. The main issue I have with the article is that, as past in other articles I’ve seen, it puts too much weight on conciseness as an indicator of expressiveness. Although conciseness often contributes to expressiveness, conciseness isn’t the only measure of expressiveness. It it were, the commenter who wrote that Python generally has a similar conciseness multiplier to C++ as Haskell, debunking this shootout’s conclusion that functional languages are “better” (i.e. more expressive), would have a strong argument.\r\n\r\nBoth the author and the commenter are making valid points, but I think they are overlooking an aspect of language expressiveness that’s at least as important, if not more important, for code quality as conciseness: readability. The reason is pretty obvious: code communicates a solution to a problem not just to computers, but also to humans. If code written in a given language is unduly hard to understand, its conciseness doesn’t hold much value because the pain of debugging and maintaining it outweights the ease of writing it. I think it’s safe to say that most programmers would prefer to work with a 1500 line solution that’s highly readable than a 1000 line solution that’s hard to comprehend.\r\n\r\nSo how does this relate to the functional vs. imperative programming debate? Although functional languages (I’m talking primarily about Erlang because that’s the functional language I know best) don’t always trump OO/imperative ones in conciseness, their code does generally wins hands down in readability.\r\n\r\nThis is especially true when comparing functional languages to dynamically-typed OO languages, whose code for anything beyond short scripts is borderline unreadable IMO. Dynamically typed OO languages trade a large degree of readability for conciseness, and that’s why Java code, as bloated as it often is, is often more readable than Python and Ruby code. The reason is in the fundamental design (flaw?) of OO languages: they encourage the programmer to bind functions to data (they name the child of this unhealthy marriage an ‘object’ to make us think this chimera models something from the “real world” :) ), and then use data objects to indirectly invoke bound (virtual) functions. If the type of an object isn’t evident in the source code, it’s difficult to figure out what functions are called when you read statements such as “obj.doSomething(param)”. Due to the abundance of indirect function calls in OO code, dynamically typed OO languages require extra discipline by the programmer to carefully document the types of all variables in his/her code so that other people have a chance to understand what functions are being called.\r\n\r\nIn my relatively brief encounter with Python, I ran into a bunch of code containing seemingly innocent idioms such as the following (I apologize in advance for Python syntax errors):\r\n\r\n    respond(channel, msg):\r\n        if channel.isValid() and msg.body().equals(\"next\"):\r\n          return channel.send(\"A2-B3\")\r\n        else:\r\n          return channel.send(\"bye\")\r\n\r\nBecause I has no idea what the types of `channel` and `msg` are (the code was poorly documented), what such snippets did was a veritable mystery. After wallowing for hours at a time in such nebulae, trying arduously to trace back to the instantiation points of mysterious parameters, where I would hope to find the golden nuggets of information indicating what types their variables are holding, my frustration would reach such uncomfortable levels that I wouldn’t know anymore whether to feel angry or deeply depressed.\r\n\r\nWhen you read Erlang code — even with scant documentation — you don’t normally have go through such troubles. Although Erlang is dynamically typed, Erlang code avoids such readability black holes because it doesn’t throw so much type information out the window. In Erlang, the above snippet would be written as follows:\r\n\r\n    respond(Channel, Msg) -&gt;\r\n      case Channel#chess_channel.is_valid &amp;&amp; Msg#chess_msg.body == next of\r\n        true -&gt; chess_channel:send(Channel, {move, a2, b3});\r\n        false -&gt; chess_channel:send(Channel, bye)\r\n      end\r\n\r\nThe Erlang code is less concise, but it’s also more readable. (It’s also more optimized because it doesn’t require the resolution of function pointers in runtime.) In a large code base, this added readability wins over conciseness because it can make difference between providing continuous service and begging your users to come back in a few more hours as you’re chasing the mysterious bug that has taken your system offline. It also helps you develop new features faster because you can spend less time debugging and more time coding.\r\n\r\nAt this point, you may be thinking, “The extra type information in Erlang code has a cost because it sacrifices generality.” If you need to write generic code, you can use Erlang’s remote function invocation as follows:\r\n\r\n    respond(ChannelType, Channel, MsgType, Msg) -&gt;\r\n      case ChannelType:is_valid(Channel) &amp;&amp; MsgType:body(Msg) == \"ok\" of\r\n        true -&gt; ChannelType:send(Channel, {move, a2, b3});\r\n        false -&gt; ChannelType:send(Channel, bye)\r\n      end.\r\n\r\nThis example is admittedly silly, but as you can see, Erlang lets you parameterize module names (and function names) in generic code. This capability is often very useful. Even with remote invocation, the vast majority of Erlang code I’ve read contains enough type information to be much more readable than imperative/OO code.\r\n\r\nIn addition to the general absence of mystery functions (for a counter-example, check out ErlyDB :) ), Erlang, and other functional languages such as Haskell, have two language features that make them more readable than imperative languages: pattern-matching and immutability.\r\n\r\n*continued in response (below)*","retrieved_on":1473809309,"distinguished":null,"gilded":0,"id":"cvww8","parent_id":"t3_uky3","edited":false,"author_flair_text":null,"author":"silly_coward","timestamp_epoch":1566236777,"message_id":"48458-84a2e56b-5774-4073-ad92-c6b987e312c5-1566236777"}
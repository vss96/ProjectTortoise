{"subreddit":"programming","author_flair_css_class":null,"created_utc":1166286408,"ups":1,"score":1,"controversiality":0,"body":"&gt; I hope we can agree on, that pattern matching is a control construct?\r\n&gt;\r\n&gt; That pattern matching is a control construct in a strict, impure language is witnessed by the rewrite rule (using Scheme notation):\r\n[...]\r\n&gt; (define-syntax my-if (syntax-rules () [(my-if a b c) (match a [#f c] [_ b])]))\r\n\r\n`match` is both a control *and* a pattern matching construct, but these are orthogonal concerns:  the pattern matching could equally have been implemented alone, without any control alteration (in which case Scheme's normal eager evaluation takes over).\r\n\r\nThe lazy `if` implementations in this thread correspond to the latter situation, where no control alteration occurs, and nothing but the language's default evaluation rules apply (which happen to already be what Scheme needs control structures to achieve).\r\n\r\nViewed from this angle, Haskell actually *does* have at least one primitive control construct:  `seq :: a -&gt; b -&gt; b`.  Where imperative control structures effectively switch from eager to minimal evaluation, though, `seq` does exactly the opposite:  it forces the evaluation of its first argument (along with any associated side effects), before returning its second.","link_id":"t3_ujj3","stickied":false,"subreddit_id":"t5_2fwo","gilded":0,"retrieved_on":1473808702,"distinguished":null,"author":"pjdelport","author_flair_text":null,"edited":false,"id":"cv172","parent_id":"t1_cv0rd","timestamp_epoch":1566236770,"message_id":"32467-87c0d8c3-2323-4039-8143-8e044fc610f6-1566236770"}